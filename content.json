{"pages":[],"posts":[{"title":"视觉生产技术","text":"视觉生产技术定义和分类视觉生产定义视觉生产就是通过一个/一系列视觉过程，产出新的视觉表达。这里的产出是指人或机器能够感知的图像视频，而不是标签或者特征并且必须是新的视觉表达，和输入的不一样。在过去，这个过程大多数是由人工来实现，但是现在我们希望通过AI技术，来产生一系列新的图像 视觉生产分类 生成:从0到1 拓展从1到N 摘要:从N到1 升维:从An到An+1 增强/变换:从A到B 插入/合成: A+B=C 擦除: A-B=C 视觉生产-通用基础框架 请求(Request)输入：参数 素材 草案 成品 案例 分发(Dispatch)生产类型： 通用生成(General) 素材合成(Assemble） 照图生图(Imitate) 视频摘要(Summary） 编辑变换(Edit) 视觉拓展(Extend) 服务(Service)视觉生产引擎： 生成引擎：模型+知识 搜索引擎：素材+案例 响应(Response)输出：素材 成品 案例 视觉生产-五个关键维度 可用：带来用户/商业价值 可控：提供用户预期的抓手 多样：保证结果的丰富性 合理：合乎语义/内容逻辑 可看：满足视觉/美学表现 精细理解分割抠图 识别:知道是什么 人的识别、物的识别 检测：识别+知道在哪儿 缺陷检测 多目标检测 分割:识别+检测 知道每一个像素是什么 全景分割 病灶分割 难点：数据严重不足,标注成本高 思路： 1、复杂问题拆解:粗mask估计+精准matting 2、丰富数据样本:设计图像mask统一模型 视觉生成 照图生图参考原图,将风格、布局等信息学习并迁移到目标致据上。 个性化设计多元化设计风格,结合商品品类、投放场景、目标客群的差异进行订制化设计. Al实现场景设计能力场景智能美工 ** **IN:营销场景+原始素材 OUT:营销图片调用方式: API 场设计初始化100-200张输入 人工还原机器学习JPG- PSD 最终输出样式PNG 模板创作机器人 图片合成机器人 视频生成-框架流程 场景选择、关联商品、素材准备、参数设置-》视频算法（编辑器支持微调）-》渲染合成-》投放、上传 编辑器支持微调： 视频植入 应用场景:广告植入 业务流程:分镜检测 视频理解：广告位检测、跟踪、遮挡检测 素材匹配:场景标签 光影渲染:边缘走样、阴影、高光、装饰 核心挑战:位置、透视、尺寸、遮挡、时间 视频摘要 视觉编辑视频内容擦除 应用:字幕、台标、广告、场景文字、人体相关内容的擦除 核心挑战和亮点:粗定位、精分割、像素填充、在线训练 视频植入 植入位检测与定位 视觉增强 单点核心技术:人脸增强、去噪音、通用场景超分、LDR升HDR、倍频、去划痕 复合应用技术:人脸修复、标清转高清、LDR-HDR互转、4K重生、老片修复、端上实时增强 核心挑战:分辨率、帧率、色彩 风格迁移 图像区域重要度分析： Self Attention GAN–m知元离区域的特征相关性 特征层计算, 1x1卷积,降低计算开销 多笔触融合 强注意力区域采用细拉度笔链,保证细节 弱注意力区域采用粗粒度等触,充分风恰化 颜色拓展 算法指标:高时效性、高合理性、高扩展度 输入:给定目的色系、给定参考图、AUTO 输出:目标图片 视觉制造实体设计制造 效率低:多次打样,多次沟通(服装设计平均30天 协同差:设计、营销、生成脱节、倒置 定制难:无法实现柔性生产 核心逻辑 服装几何生成 视觉迁移及融合 多样拓展性 视觉开放平台定位 聚合阿里巴巴视觉(国像/视频/3D图形)原能力,以云上API方式统一提供服务; 建设视觉智能API开放平台,高效管理视觉!法能力生命周期,提供相应效率工具； 基于平台上的API能力,建设双向进入和使机制,扩大开发者生态,打造行业用户心智； 建设和运营阿里视觉平台品牌,扩大影响力,得能力提供者和使用者欢赢 一站式能力选择 规模化:将在平台荟萃数百个AP能力; 多样化:针对多种媒体(图像、视频、3D)多种对象的多个能力; 细粒度:原子化、被集成,解决细粒度的具体问题 场景化:有价值,能实用,针对特定场景特定优化的能力。","link":"/2020/05/27/day1/"},{"title":"电子相册搭建","text":"电子相册搭建（人脸、表情识别） 表情识别功能描述RecognizeExpression可以检测和识别图片中人脸的表情。表情种类为：neutral（中性）、happiness（高兴）、surprise（惊讶）、sadness（伤心）、anger（生气）、disgust（厌恶）、fear（害怕）。 输入限制 图片分辨率：分辨率要求大于5×5像素。 图片大小：图片大小不超过3M。 人脸尺寸：建议大于64×64像素。 请求参数 名称 类型 是否必选 示例值 描述 Action String 是 RecognizeExpression 系统规定参数。取值：RecognizeExpression。 ImageURL String 是 https://viapi-test.oss-cn-shanghai.aliyuncs.com/test/facebody/RecognizeBrow/brow.jpg 图片URL地址。 返回数据 名称 类型 示例值 描述 Data Struct 返回的结果数据内容。 Elements Array 各个子元素的识别结果。 Expression String surprise 表情类别。枚举类型：neutral、happiness、surprise、sadness、anger、disgust、fear。 FaceProbability Float 0.99651491641998291 检测结果的概率，取值范围为0~1。 FaceRectangle Struct 人脸区域信息。 Height Integer 174 人脸区域的高度。 Left Integer 196 人脸区域的左上角x坐标。 Top Integer 41 人脸区域的左上角y坐标。 Width Integer 121 人脸区域的宽度。 RequestId String E1C4C576-1799-4079-A934-15BC406A54EF 请求ID。 示例请求示例http(s)://facebody.cn-shanghai.aliyuncs.com/?Action=RecognizeExpression&amp;ImageURL=https://viapi-test.oss-cn-shanghai.aliyuncs.com/test/facebody/RecognizeBrow/brow.jpg&amp;&lt;公共请求参数&gt;返回示例（JSON）{ “RequestId”: “E1C4C576-1799-4079-A934-15BC406A54EF”, “Data”: { “Elements”: [ { “Expression”: “surprise”, “FaceRectangle”: { “Left”: 196, “Top”: 41, “Height”: 174, “Width”: 121 }, “FaceProbability”: “0.99651491641998291” } ] }} 场景识别功能描述RecognizeScene可以识别图像中的场景环境，支持数十种常见场景，包括：人物、会议室、公路、其他、办公室、动物、卧室、商场、地铁、夜景、天空、婚礼、室内、室外、小河、山峰、广场、建筑、户外、手机、旅行、日出、日落、显示器、树林、植物、水果、汽车、沙滩、沙漠、海滨、游乐场、湖、演出、火车、烧烤、物品、 狗、猫、美食、聚餐、自行车、船、花、草地、蔬菜、街景、街道、运动、运动场、露营、飞机、餐厅、鱼、鸟。 输入限制 请求格式：JPEG、JPG、PNG、BMP。 图像大小：图像大小不超过3M。 图像分辨率：图片要求5×5像素以上。请求参数 名称 类型 是否必选 示例值 描述 Action String 是 RecognizeScene 系统规定参数。取值：RecognizeScene。 ImageURL String 是 https://viapi-demo.oss-cn-shanghai.aliyuncs.com/viapi-demo/images/DetectImageElements/detect-elements-src.png 图片URL地址。当前仅支持上海地域的OSS链接，如何生成图片URL请参见生成URL。 返回数据 名称 类型 示例值 描述 Data Struct 返回的结果数据内容。 | Tags | Array | | tags输出，对应正常、性感、色情三个标签的输出分数，每个标签会输出confidence和value两个参数，value是标签名称，confidence是对应分数，范围0100。输出标签数量最少1个，最多5个，如果某个类别标签未输出，则对应的confidence为零。 || Confidence | Float | 97 | 分数，范围0100。 || Value | String | 人物 | 标签名称。 || RequestId | String | 3602D349-D892-43EA-ADF5-13DC714F3547 | 请求ID。 | 示例请求示例http(s)://imagerecog.cn-shanghai.aliyuncs.com/?Action=RecognizeScene&amp;ImageURL=https://viapi-demo.oss-cn-shanghai.aliyuncs.com/viapi-demo/images/DetectImageElements/detect-elements-src.png&amp;&lt;公共请求参数&gt;返回示例（JSON）{ “RequestId”: “3602D349-D892-43EA-ADF5-13DC714F3547”, “Data”: { “Tags”: [ { “Confidence”: 97, “Value”: “人物” }, { “Confidence”: 11, “Value”: “其他” }, { “Confidence”: 11, “Value”: “运动” }, { “Confidence”: 11, “Value”: “物品” }, { “Confidence”: 11, “Value”: “演出” } ] }}","link":"/2020/05/27/day3/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/05/21/hello-world/"},{"title":"身份证识别系统搭建","text":"Day 2 - 身份证识别系统搭建 身份证识别功能描述RecognizeIdentityCard可以识别二代身份证关键字段内容，关键字段包括：姓名、性别、民族、身份证号、出生日期、地址信息、有效起始时间、签发机关，同时可输出身份证区域位置和人脸位置信息。 输入限制 图片格式：JPEG、JPG、PNG、BMP、GIF。 图像大小：图像大小不超过3M。 图像分辨率：不限制图片分辨率，但图片分辨率太高可能会导致API识别超时，超时时间为5秒。 请求参数 名称 类型 是否必选 示例值 描述 Action String 是 RecognizeIdentityCard 系统规定参数。取值：RecognizeIdentityCard。 ImageURL String 是 https://viapi-demo.oss-cn-shanghai.aliyuncs.com/viapi-demo/images/DetectImageElements/detect-elements-src.png 图片URL地址。 Side String 是 face 身份证正反面类型。- face：正面。- back：反面。 返回数据 名称 类型 示例值 描述 Data Struct 返回的结果数据内容。 BackResult Struct 反面照结果。 EndDate String 19800101 有效期结束时间，格式：YYYYMMDD，例如19800101，即1980年01月01日。 Issue String 杭州市公安局 签发机关。 StartDate String 19700101 有效期起始时间，格式：YYYYMMDD，例如19800101，即1980年01月01日。 FrontResult Struct 正面照结果。 Address String 浙江省杭州市余杭区文一西路969号 地址信息。 BirthDate String 20000101 出生日期，格式：YYYYMMDD，例如19800101，即1980年01月01日。 CardAreas Array 身份证区域位置，四个顶点表示，顺序是逆时针（左上、左下、右下、右上）。 X Float 165 身份证区域横坐标。 Y Float 657 身份证区域纵坐标。 FaceRectVertices Array 人脸位置，四个顶点表示。 X Float 1024.6600341796875 人脸位置横坐标。 Y Float 336.629638671875 人脸位置纵坐标。 FaceRectangle Struct 人脸位置。 Angle Float -90 表示矩形顺时针旋转的度数，范围-180~180。 Center Struct 人脸矩形中心坐标。 X Float 952 人脸矩形中心横坐标。 Y Float 325.5 人脸矩形中心纵坐标。 Size Struct 人脸矩形尺寸。 Height Float 181.99 高度。 Width Float 164.99 宽度。 Gender String 男 性别。 IDNumber String 1234567890 身份证号。 Name String 张三 姓名。 Nationality String 汉 民族。 RequestId String D6C24839-91A7-41DA-B31F-98F08EF80CC0 请求ID。 返回数据示例请求示例 1234http(s)://ocr.cn-shanghai.aliyuncs.com/?Action=RecognizeIdentityCard&amp;ImageURL=https://viapi-demo.oss-cn-shanghai.aliyuncs.com/viapi-demo/images/DetectImageElements/detect-elements-src.png&amp;Side=face&amp;&lt;公共请求参数&gt; 正常返回示例XML 格式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;RequestId&gt;D6C24839-91A7-41DA-B31F-98F08EF80CC0&lt;/RequestId&gt;&lt;Data&gt; &lt;FrontResult&gt; &lt;Address&gt;浙江省杭州市余杭区文一西路969号&lt;/Address&gt; &lt;Name&gt;张三&lt;/Name&gt; &lt;Nationality&gt;汉&lt;/Nationality&gt; &lt;IDNumber&gt;1234567890&lt;/IDNumber&gt; &lt;Gender&gt;男&lt;/Gender&gt; &lt;BirthDate&gt;20000101&lt;/BirthDate&gt; &lt;FaceRectangle&gt; &lt;Angle&gt;-90&lt;/Angle&gt; &lt;Center&gt; &lt;X&gt;952&lt;/X&gt; &lt;Y&gt;325.5&lt;/Y&gt; &lt;/Center&gt; &lt;Size&gt; &lt;Height&gt;181.99&lt;/Height&gt; &lt;Width&gt;164.99&lt;/Width&gt; &lt;/Size&gt; &lt;/FaceRectangle&gt; &lt;CardAreas&gt; &lt;X&gt;165&lt;/X&gt; &lt;Y&gt;657&lt;/Y&gt; &lt;/CardAreas&gt; &lt;CardAreas&gt; &lt;X&gt;534&lt;/X&gt; &lt;Y&gt;658&lt;/Y&gt; &lt;/CardAreas&gt; &lt;CardAreas&gt; &lt;X&gt;535&lt;/X&gt; &lt;Y&gt;31&lt;/Y&gt; &lt;/CardAreas&gt; &lt;CardAreas&gt; &lt;X&gt;165&lt;/X&gt; &lt;Y&gt;30&lt;/Y&gt; &lt;/CardAreas&gt; &lt;FaceRectVertices&gt; &lt;X&gt;1024.6600341796875&lt;/X&gt; &lt;Y&gt;336.629638671875&lt;/Y&gt; &lt;/FaceRectVertices&gt; &lt;FaceRectVertices&gt; &lt;X&gt;906.6610717773438&lt;/X&gt; &lt;Y&gt;336.14801025390625&lt;/Y&gt; &lt;/FaceRectVertices&gt; &lt;FaceRectVertices&gt; &lt;x&gt;907.1590576171875&lt;/x&gt; &lt;Y&gt;214.1490478515625&lt;/Y&gt; &lt;/FaceRectVertices&gt; &lt;FaceRectVertices&gt; &lt;x&gt;1025.157958984375&lt;/x&gt; &lt;Y&gt;214.63067626953125&lt;/Y&gt; &lt;/FaceRectVertices&gt; &lt;/FrontResult&gt;&lt;/Data&gt; JSON 格式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960{\"RequestId\": \"D6C24839-91A7-41DA-B31F-98F08EF80CC0\",\"Data\": { \"FrontResult\": { \"Address\": \"浙江省杭州市余杭区文一西路969号\", \"Name\": \"张三\", \"Nationality\": \"汉\", \"IDNumber\": \"1234567890\", \"Gender\": \"男\", \"BirthDate\": \"20000101\", \"FaceRectangle\": { \"Angle\": -90, \"Center\": { \"X\": 952, \"Y\": 325.5 }, \"Size\": { \"Height\": 181.99, \"Width\": 164.99 } }, \"CardAreas\": [ { \"X\": 165, \"Y\": 657 }, { \"X\": 534, \"Y\": 658 }, { \"X\": 535, \"Y\": 31 }, { \"X\": 165, \"Y\": 30 } ], \"FaceRectVertices\": [ { \"X\": 1024.6600341796875, \"Y\": 336.629638671875 }, { \"X\": 906.66107177734375, \"Y\": 336.14801025390625 }, { \"x\": 907.1590576171875, \"Y\": 214.1490478515625 }, { \"x\": 1025.157958984375, \"Y\": 214.63067626953125 } ] }}} JAVA SDK引入POM包&lt;artifactId&gt;ocr20191230&lt;/artifactId&gt;。 12345&lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;ocr20191230&lt;/artifactId&gt; &lt;version&gt;${aliyun.ocr.version}&lt;/version&gt;&lt;/dependency&gt; 说明 您可以通过[https://mvnrepository.com/artifact/com.aliyun/](https://mvnrepository.com/artifact/com.aliyun/)**SDK包名称**查看不同服务SDK的版本。例如[https://mvnrepository.com/artifact/com.aliyun/aliyun-java-sdk-ocr](https://mvnrepository.com/artifact/com.aliyun/aliyun-java-sdk-ocr)查看aliyun-java-sdk-ocr的版本。接入SDK下面介绍新版本的参数构建和调用方法。 引入资源。在pom.xml文件中添加Maven依赖安装java SDK。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;version&gt;4.4.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.52&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;ocr20191230&lt;/artifactId&gt; &lt;version&gt;${aliyun.ocr.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;facebody20191230&lt;/artifactId&gt; &lt;version&gt;${aliyun.facebody.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;imagerecog20190930&lt;/artifactId&gt; &lt;version&gt;${aliyun.imagerecog.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;imageseg20191230&lt;/artifactId&gt; &lt;version&gt;${aliyun.imageseg.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;imageenhan20190930&lt;/artifactId&gt; &lt;version&gt;${aliyun.imageenhan.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;goodstech20191230&lt;/artifactId&gt; &lt;version&gt;${aliyun.goodstech.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;objectdet20191230&lt;/artifactId&gt; &lt;version&gt;${aliyun.objectdet.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;imgsearch20200320&lt;/artifactId&gt; &lt;version&gt;${aliyun.imgsearch.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;videorecog20200320&lt;/artifactId&gt; &lt;version&gt;${aliyun.videorecog.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;videoseg20200320&lt;/artifactId&gt; &lt;version&gt;${aliyun.videoseg.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;videoenhan20200320&lt;/artifactId&gt; &lt;version&gt;${aliyun.videoenhan.version}&lt;/version&gt;&lt;/dependency&gt; 构建Client。示例如下： 12345678910// 你的accessKeyId config.accessKeyId=\"######\"; //你的accessKeySecret config.accessKeySecret=\"#######\"; config.type=\"access_key\"; config.regionId=\"cn-shanghai\"; config.endpointType=\"internal\"; Client client = new Client(config); config.endpoint=\"ocr.cn-shanghai.aliyuncs.com\"; //此处endpoint以文字识别为例。不同服务的Endpoint参见访问域名。 调用服务。Client已经封装好需要调用的能力，且大多数API支持本地文件。 使用URL request：RecognizeIdentityCard 方法：recognizeIdentityCard 示例123456789101112private static void RecognizeIdentityCard(Client client, RuntimeOptions runtimeOptions) throws Exception { try { RecognizeIdentityCardRequest req = new RecognizeIdentityCardRequest(); req.imageURL=\"https://viapi-demo.oss-cn-shanghai.aliyuncs.com/viapi-demo/images/RecognizeIdentityCard/IdentityCard.jpg\"; RecognizeIdentityCardResponse rep = client.recognizeBankCard(req, runtimeOptions); System.out.println(\"身份证识别=\"+JSON.toJSONString(rep)); } catch (TeaException e){ System.out.println(\"身份证识别异常了\"); System.out.println(JSON.toJSONString(e.getData())); } } 使用本地文件 request：RecognizIdentityCardAdvanceRequest 方法：recognizeIdentityCardAdvance 示例12345678910111213private static void RecognizeIdentityCardAdvance(Client client, RuntimeOptions runtimeOptions) throws Exception { try { RecognizeIdentityCardAdvanceRequest req = new RecognizeBankCardAdvanceRequest(); InputStream inputStream = new FileInputStream(new File(\"/Users/robinqu/Library/IdentityCard.png\")); req.imageURLObject=inputStream; RecognizeIdentityCardResponse rep = client.recognizeBankCardAdvance(req, runtimeOptions); System.out.println(\"银行卡识别=\"+JSON.toJSONString(rep)); } catch (TeaException e){ System.out.println(\"银行卡识别异常了\"); System.out.println(JSON.toJSONString(e.getData())); } } 出现advance表示使用本地文件，没有则表示使用公网可以访问的URL。 结果示例对于同一个接口，如果SDK中包含类似xxxAdvanceRequest的结构，那么这个接口支持本地文件上传，否则不支持。例如下图中ChangeImageSize是支持本地文件的，而RecolorImage则不支持本地文件，只支持OSS链接。 异常相关如果调用发生异常，则异常信息会在TeaException.getData()中显示出来。 123456{ \"RequestId\": \"6B8A283F-DFFA-4F30-9DF1-A85D8609AD88\", \"HostId\": \"ocr.cn-shanghai.aliyuncs.com\", \"Code\": \"InvalidImage.Content\", \"Message\": \"Invalid Input - wrong category\"}","link":"/2020/05/25/My-Gallery/"},{"title":"培训学校管理系统","text":"1.定模型（类） 总部 分校 员工 老师 学员 课程 班级 2.定属性 总部 名字、地址、电话、网址 银行账户 员工列表 学员列表 分校列表 发工资 开分校 开课 开班 招聘 统计账户余额 统计员工人数 统计学员人数 分校 继承总校 员工 姓名、年龄、职务、部门、工资、所属校区、入职时间 老师 继承员工 上课 学员 姓名、年龄、学历 班级 账户余额 课程 名称 价格 学历要求 大纲 班级 校区 编号 开设课程 开课日期 学员列表 学员退学、转学 3.定关系 总部 –&gt; 分校 学员 –&gt; 班级 课程 –&gt; 班级 班级 –&gt; 分校 老师 –&gt; 员工 老师 –&gt; 课程 4.画UML图5.写代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class School: \"\"\"学校总部\"\"\" def __init__(self, name, addr, phone, website): self.name = name self.addr = addr self.phone = phone self.website = website self.branches = {} self.__staff_list = [] self.__stu_list = [] self.__bank_account_balance = 0 print('初始化校区{},地址：{},电话：{},网址：{}'.format(self.name, self.addr, self.phone, self.website)) def count_staff_num(self): \"\"\"统计各分校员工数\"\"\" total_staff_num = len(self.__staff_list) return total_staff_num def count_stu_num(self): \"\"\"统计学员数\"\"\" total_stu_num = len(self.__stu_list) return total_stuf_num def pay_roll(self): \"\"\"发工资\"\"\" pass def new_staff_enrollment(self, staff_obj): \"\"\"添加员工\"\"\" self.__staff_list.append(staff_obj) def open_course(self): \"\"\"开课\"\"\" pass def open_class(self): \"\"\"开班\"\"\" passclass BranchSchool(School): def __init__(self, name, addr, phone, headquater_obj): super().__init__(website) self.headquater_obj = headquater_obj self.headquater_obj.branches[name] = self headquater = School(\"达外北京总部\",\"亦庄凉水河一街9号\",\"010-87228722\",\"www.dawai.cn\") 初始化校区达外北京总部,地址：亦庄凉水河一街9号,电话：010-87228722,网址：www.dawai.cn 完成所有类代码 初始化总部 初始化北京分校、上海分校、上海一分校、上海二分校 初始化三门课程 初始化三个班级 初始化若干员工 初始化若干教师 初始化若干学员 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146import timeclass School(object): \"\"\"学校基类，总部校区\"\"\" def __init__(self,name,addr): self.name = name self.addr = addr self.branches = {} # 下属分校 self.__staff_list = [] # 员工列表 self.__bank_account_balance = 0 # 财务账号 print(\"初始化校区[%s],地址:%s...\" % (self.name,self.addr)) def count_staff_num(self): \"\"\"统计公司各分校员工人数\"\"\" total_staff_num = len(self.__staff_list) for i in self.branches: total_staff_num += self.branches[i].count_staff_num() # 统计分校人数 print(\"[%s]总员工数量:%s\" % (self.name, total_staff_num)) return total_staff_num def pay_roll(self): \"\"\"发工资\"\"\" def new_staff_enrollment(self,staff_obj): \"\"\"添加新员工\"\"\" self.__staff_list.append(staff_obj) def count_total_balance(self): balance = self.__bank_account_balance for branch_name,branch_obj in self.branches.items(): balance += branch_obj.__bank_account_balance print(\"Total balance:\",balance) def open_course(self): pass def open_class(self): pass def show_balance(self): print(\"[%s]账户余额:%s\" %( self.name,self.__bank_account_balance)) def money_transfer_in(self,amount,from_obj,purpose): \"\"\" 收钱 :param amount: :param from_obj: :param purpose: :return: \"\"\" self.__bank_account_balance += amount print(\"%s,校区[%s]收到[%s]转账[%s],交费原因[%s]...\" % (time.strftime(\"%Y-%m-%d %H:%M:%S\"), self.name,from_obj.name,amount,purpose))class BranchSchool(School): \"\"\"分校\"\"\" def __init__(self,name,addr,headquater_obj): super().__init__(name,addr) self.headquater_obj = headquater_obj # 总部的对象 self.headquater_obj.branches[name] = self # 把自己添加到总部的分校列表class Course(object): \"\"\"课程类\"\"\" def __init__(self,name,fee,degree_requirement,): self.name = name self.fee = fee # 学费 self.degree_requirement = degree_requirement # 学历要求class Class(object): \"\"\"班级类\"\"\" def __init__(self,course_obj,school_obj,class_num,start_date): self.class_num = class_num # 班级编号 self.start_date = start_date # 开班日期 self.course_obj = course_obj # 开设的课程 self.school_obj = school_obj # 所在校区 self.stu_list = [] # 学员列表 print(\"校区[%s]开设了[%s]课程第[%s]班,开班日期[%s]...\" %( school_obj.name ,course_obj.name ,class_num,start_date)) def get_class_name(self): return \"%s-%s-s%s期\" %(self.school_obj.name,self.course_obj.name,self.class_num) def drop_out(self,stu_obj): \"\"\"退学\"\"\" self.stu_list.remove(stu_obj) print(\"学员[%s]从[%s]退学了....\" % (stu_obj.name,self.get_class_name()))class Staff(object): \"\"\"员工类\"\"\" def __init__(self,name,age,position,salary,dept,school_obj,on_board_date): self.name = name self.age = age self.position = position # 职位 self.salary = salary self.dept = dept # 部门 self.school_obj = school_obj # 所属校区 self.on_board_date = on_board_date # 入职日期 print(\"校区[%s]的[%s]部门在[%s]入职一名新同事[%s],职位是[%s]\" % (school_obj.name ,dept,on_board_date, name,position)) school_obj.new_staff_enrollment(self)class Teacher(Staff): \"\"\"讲师\"\"\" def teaching(self,class_obj): \"\"\" 上课 :param class_obj: 上课的班级 \"\"\" passclass Student(object): def __init__(self,name,age,degree,class_obj,balance): self.name = name self.age = age self.degree = degree self.class_obj = class_obj # 报名班级对象 self.balance = balance # 这个学生账户余额 self.class_obj.stu_list.append(self) # 添加学生到这个班级 def pay_tuition(self): \"\"\"交学费\"\"\" self.balance -= self.class_obj.course_obj.fee # 交学费 self.class_obj.school_obj.money_transfer_in(self.class_obj.course_obj.fee,self,\"交%s学费\"%self.class_obj.get_class_name()) def __repr__(self): return \"学生:%s,班级:%s\" %(self.name,self.class_obj.get_class_name())# 初始化总部及校区headquater = School(\"达外北京总部\",\"北京凉水河一街9号\")bj1 = BranchSchool(\"达外北京分校\",\"北京亦庄经济技术开发区\",headquater)sh = BranchSchool(\"达外上海分校\",\"上海张江科技园\",headquater)sh1 = BranchSchool(\"达外上海1分校\",\"上海虹桥机场\",sh)sh2 = BranchSchool(\"达外上海2分校\",\"上海虹桥火车站\",sh)sz1 = BranchSchool(\"达外深圳分校\",\"深圳南山大学城1号\",headquater)# 初始化员工staff1 = Staff(\"王达外\",32,\"CEO\",60000,\"总经办\",headquater,\"2017-05-22\")staff2 = Staff(\"周达内\",23,\"HR\",6000,\"HR\",headquater,\"2018-03-12\")t1 = Teacher(\"马骏\",27,\"前端开发讲师\",30000,\"教研部\",bj1,\"2018-02-26\")t2 = Teacher(\"牛牡\",25,\"Python讲师\",45000,\"教研部\",sz1,\"2018-07-14\")t3 = Teacher(\"张弛\",23,\"Go讲师\",40000,\"教研部\",sh1,\"2018-07-14\")# 初始化课程py_course = Course(\"Python开发\",21800,\"本科\")linux_course = Course(\"Linux云计算运维\",19800,\"专科\")go_course = Course(\"GO开发\",9800,\"本科\")# 初始化班级class1 = Class(py_course,bj1,21,\"2019-07-06\")class2 = Class(linux_course,sz1,4,\"2019-06-16\")class3 = Class(go_course,sh1,11,\"2019-09-21\")# 初始化学员stu1 = Student(\"孙小空\",22,\"本科\",class1,30000)stu2 = Student(\"朱小戒\",23,\"专科\",class2,25000)stu3 = Student(\"沙小僧\",26,\"本科\",class3,13000)stu4 = Student(\"刘小贝\",21,\"本科\",class3,10000)stu5 = Student(\"张小飞\",21,\"专科\",class1,20000)for i in (stu1,stu2,stu3,stu4): i.pay_tuition()print(class3.stu_list)bj1.show_balance()sh1.show_balance()sh2.show_balance()sz1.show_balance()headquater.count_total_balance()headquater.count_staff_num()print(headquater.branches)# 退学stu5.class_obj.drop_out(stu5) 初始化校区[达外北京总部],地址:北京凉水河一街9号... 初始化校区[达外北京分校],地址:北京亦庄经济技术开发区... 初始化校区[达外上海分校],地址:上海张江科技园... 初始化校区[达外上海1分校],地址:上海虹桥机场... 初始化校区[达外上海2分校],地址:上海虹桥火车站... 初始化校区[达外深圳分校],地址:深圳南山大学城1号... 校区[达外北京总部]的[总经办]部门在[2017-05-22]入职一名新同事[王达外],职位是[CEO] 校区[达外北京总部]的[HR]部门在[2018-03-12]入职一名新同事[周达内],职位是[HR] 校区[达外北京分校]的[教研部]部门在[2018-02-26]入职一名新同事[马骏],职位是[前端开发讲师] 校区[达外深圳分校]的[教研部]部门在[2018-07-14]入职一名新同事[牛牡],职位是[Python讲师] 校区[达外上海1分校]的[教研部]部门在[2018-07-14]入职一名新同事[张弛],职位是[Java讲师] 校区[达外北京分校]开设了[Python开发]课程第[21]班,开班日期[2019-07-06]... 校区[达外深圳分校]开设了[Linux云计算运维]课程第[4]班,开班日期[2019-06-16]... 校区[达外上海1分校]开设了[GO开发]课程第[11]班,开班日期[2019-09-21]... 2019-10-16 09:55:31,校区[达外北京分校]收到[孙小空]转账[21800],交费原因[交达外北京分校-Python开发-s21期学费]... 2019-10-16 09:55:31,校区[达外深圳分校]收到[朱小戒]转账[19800],交费原因[交达外深圳分校-Linux云计算运维-s4期学费]... 2019-10-16 09:55:31,校区[达外上海1分校]收到[沙小僧]转账[9800],交费原因[交达外上海1分校-GO开发-s11期学费]... 2019-10-16 09:55:31,校区[达外上海1分校]收到[刘小贝]转账[9800],交费原因[交达外上海1分校-GO开发-s11期学费]... [学生:沙小僧,班级:达外上海1分校-GO开发-s11期, 学生:刘小贝,班级:达外上海1分校-GO开发-s11期] [达外北京分校]账户余额:21800 [达外上海1分校]账户余额:19600 [达外上海2分校]账户余额:0 [达外深圳分校]账户余额:19800 Total balance: 41600 [达外北京分校]总员工数量:1 [达外上海1分校]总员工数量:1 [达外上海2分校]总员工数量:0 [达外上海分校]总员工数量:1 [达外深圳分校]总员工数量:1 [达外北京总部]总员工数量:5 {&apos;达外北京分校&apos;: &lt;__main__.BranchSchool object at 0x1049a2c50&gt;, &apos;达外上海分校&apos;: &lt;__main__.BranchSchool object at 0x1049a2e10&gt;, &apos;达外深圳分校&apos;: &lt;__main__.BranchSchool object at 0x1049a2ef0&gt;} 学员[张小飞]从[达外北京分校-Python开发-s21期]退学了....12","link":"/2020/05/26/%E5%9F%B9%E8%AE%AD%E5%AD%A6%E6%A0%A1%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"title":"面向对象程序设计1","text":"人狗大战我们接到了一个游戏开发任务，需要开发一款叫做“人狗大战”的游戏。 思考： 人狗大战，那至少需要2个角色，一个是人， 一个是狗，且人和狗都有不同的技能，比如人可以打狗， 狗可以咬人，怎么描述这种不同的角色和他们的功能呢？ 角色 狗：名字、种类、攻击力、生命值… 人：名字、年龄 动作 狗咬人 人打狗 1234567891011121314151617181920# 用字典定义角色#一条狗dog = { \"name\":\"大黄\", \"d_type\":\"金毛\", \"attack_val\":70, \"hp\":100}# 用函数定义动作def bite(person): person.hp -= 30 # 另一条狗# 参数相同，值不同dog2 = { \"name\":\"老黑\", \"d_type\":\"藏獒\", \"attack_val\":150, \"hp\":150} 为了避免重复，可以把字典也写成函数： 12345678910111213def dog(name, d_type, attack_val, hp): data = { \"name\":name, \"d_type\":d_type, \"attack_val\":attack_val, \"hp\":hp } return datad1 = dog(\"大黄\",\"金毛\",70,70)d2 = dog(\"老黑\",\"藏獒\",150,150)print(d1)print(d2) {&apos;name&apos;: &apos;大黄&apos;, &apos;d_type&apos;: &apos;金毛&apos;, &apos;attack_val&apos;: 70, &apos;hp&apos;: 70} {&apos;name&apos;: &apos;老黑&apos;, &apos;d_type&apos;: &apos;藏獒&apos;, &apos;attack_val&apos;: 150, &apos;hp&apos;: 150}可以这样认为： 函数dog就是一个狗的模板 变量d1和d2就是基于这个模板创建的实体 我们还可以把狗的attack_val和与狗的d_type关联起来，给hp设置一个默认值： 123456789101112131415161718attack_vals = { \"金毛\":70, \"藏獒\":150}def dog(name, d_type): data = { \"name\":name, \"d_type\":d_type, \"hp\":100 } if d_type in attack_vals: data[\"attack_val\"] = attack_vals[d_type] return datad1 = dog(\"大黄\",\"金毛\")d2 = dog(\"老黑\",\"藏獒\")print(d1)print(d2) {&apos;name&apos;: &apos;大黄&apos;, &apos;d_type&apos;: &apos;金毛&apos;, &apos;hp&apos;: 100, &apos;attack_val&apos;: 70} {&apos;name&apos;: &apos;老黑&apos;, &apos;d_type&apos;: &apos;藏獒&apos;, &apos;hp&apos;: 100, &apos;attack_val&apos;: 150}接下来照方抓药，把人的角色也写出来： 12345678910111213141516def person(name, age): data = { \"name\":name, \"age\":age, \"hp\":100 } if age &gt; 18: data[\"attack_val\"] = 50 else: data[\"attack_val\"] = 30 return datap1 = person('Tom', 25)p2 = person('Jerry', 17)print(p1)print(p2) {&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 25, &apos;hp&apos;: 100, &apos;attack_val&apos;: 50} {&apos;name&apos;: &apos;Jerry&apos;, &apos;age&apos;: 17, &apos;hp&apos;: 100, &apos;attack_val&apos;: 30}接下来是动作，动作可以让角色直接产生交互： 123456def dog_bite(dog_obj, person_obj): person_obj['hp'] -= dog_obj['attack_val'] print('狗[%s]咬了人[%s]一口，人生命值减少[%s]，生命值还剩[%s]...'%(dog_obj['name'], person_obj['name'], dog_obj['attack_val'], person_obj['hp'])) 合并一下，完成交互： 1234567891011121314151617181920212223242526272829303132333435attack_vals = { \"金毛\":70, \"藏獒\":150}def dog(name, d_type): data = { \"name\":name, \"d_type\":d_type, \"hp\":100 } if d_type in attack_vals: data[\"attack_val\"] = attack_vals[d_type] return datadef person(name, age): data = { \"name\":name, \"age\":age, \"hp\":100 } if age &gt; 18: data[\"attack_val\"] = 50 else: data[\"attack_val\"] = 30 return datadef dog_bite(dog_obj, person_obj): person_obj['hp'] -= dog_obj['attack_val'] print('狗[%s]咬了人[%s]一口，人生命值减少[%s]，生命值还剩[%s]...'%(dog_obj['name'], person_obj['name'], dog_obj['attack_val'], person_obj['hp']))p1 = person('Tom', 25)p2 = person('Jerry', 17)d1 = dog(\"大黄\",\"金毛\")d2 = dog(\"老黑\",\"藏獒\")dog_bite(d1, p1) 狗[大黄]咬了人[Tom]一口，人生命值减少[70]，生命值还剩[30]...练习：在刚才程序的基础上增加一个人打狗的函数person_beat 接下来考虑一个问题： 如果我们在交互的时候不小心写错了会怎么样？ 比如：dog_bite(p1, d1) 123456def person_beat(person_obj, dog_obj): dog_obj['hp'] -= person_obj['attack_val'] print('人[%s]打了狗[%s]一棒，狗生命值减少[%s]，生命值还剩[%s]...'%(person_obj['name'], dog_obj['name'], person_obj['attack_val'], dog_obj['hp'])) 1234567891011121314151617181920212223242526272829303132333435attack_vals = { \"金毛\":70, \"藏獒\":150}def dog(name, d_type): data = { \"name\":name, \"d_type\":d_type, \"hp\":100 } if d_type in attack_vals: data[\"attack_val\"] = attack_vals[d_type] return datadef person(name, age): data = { \"name\":name, \"age\":age, \"hp\":100 } if age &gt; 18: data[\"attack_val\"] = 50 else: data[\"attack_val\"] = 30 return datadef dog_bite(dog_obj, person_obj): person_obj['hp'] -= dog_obj['attack_val'] print('狗[%s]咬了人[%s]一口，人生命值减少[%s]，生命值还剩[%s]...'%(dog_obj['name'], person_obj['name'], dog_obj['attack_val'], person_obj['hp']))p1 = person('Tom', 25)p2 = person('Jerry', 17)d1 = dog(\"大黄\",\"金毛\")d2 = dog(\"老黑\",\"藏獒\")dog_bite(p1, d1) 狗[Tom]咬了人[大黄]一口，人生命值减少[50]，生命值还剩[50]...按照正常逻辑，dog_bite只能狗来使用，person_beat只能人使用，否则就会产生逻辑混乱。 怎么解决这个问题呢？ 我们可以增加一些判断，也可以把dog_bite函数写到dog函数内部… 总结其实上面写的代码，就是面向对象的代码。 我们在设计角色时，为了让一个角色可以变成多个实体对象，设计了一个基础模板，只要传入不同参数，就会产生不同的狗。 这代表我们已经开始切换成上帝视角看事情 ，上帝视角就是面向对象编程的视角，上帝要造世界万物，他肯定不是一个一个的造出来，他肯定是设计出一个个的物种的模板，然后通过模子批量批一个个的实体造出来。造出来的实体各有特色，属性、功能都不尽相同，这些人之间会发生什么关系 ，上帝懒的管，上帝只控制大局。 面向过程 VS 面向对象编程范式编程是程序员用特定的语法+数据结构+算法组成的代码来告诉计算机如何执行任务的过程 ，一个程序是程序员为了得到一个任务结果而编写的一组指令的集合。 正所谓条条大路通罗马，实现一个任务的方式有很多种不同的方式， 对这些不同的编程方式的特点进行归纳总结出来的编程方式类别，即为编程范式。 不同的编程范式本质上代表对各种类型的任务采取的不同的解决问题的思路， 大多数语言只支持一种编程范式，当然也有些语言可以同时支持多种编程范式。 两种最重要的编程范式分别是面向过程编程和面向对象编程。 面向过程编程(Procedural Programming) Procedural programming uses a list of instructions to tell the computer what to do step-by-step. 面向过程编程依赖procedures，一个procedure包含一组要被进行计算的步骤， 面向过程又被称为top-down languages， 就是程序从上到下一步步执行，一步步从上到下，从头到尾的解决问题 。基本设计思路就是程序一开始是要着手解决一个大的问题，然后把一个大问题分解成很多个小问题或子过程，这些子过程再执行的过程再继续分解直到小问题足够简单到可以在一个小步骤范围内解决。 举个典型的面向过程的例子， 有个需求是对网站日志进行分析，生成邮件报告，整个流程分以下几步： 到各台服务器上收集日志，因为有多台网站服务器，共同对外提供服务 对日志进行各种维度分析，比如pv,uv, 来源地区、访问的设备等 生成报告，发送邮件 代码如下: 1234567891011121314151617181920212223# 1 整合日志def collect_logs(): print(\"log on server A ,get access.log\") print(\"log on server B ,get access.log\") print(\"log on server C ,get access.log\") print(\"combine logs in to one file\")# 2 日志分析def log_analyze(log_file): print(\"pv、uv分析....\") print(\"用户来源分析....\") print(\"访问的设备来源分析....\") print(\"页面停留时间分析....\") print(\"入口页面分析....\")# 3 生成报告并发送def send_report(report_data): print(\"connect email server...\") print(\"send email....\")def main(): collect_logs() log_analyze('my_db') send_report()if __name__ == '__main__': main() 这样做的问题也是显而易见的，就是如果你要对程序进行修改，对你修改的那部分有依赖的各个部分你都也要跟着修改， 举个例子，如果程序开头你设置了一个变量值为1 ，但如果其它子过程依赖这个值为1的变量才能正常运行，那如果你改了这个变量，那这个子过程你也要修改，假如又有一个其它子程序依赖这个子过程 ，那就会发生一连串的影响，随着程序越来越大，这种编程方式的维护难度会越来越高。 所以我们一般认为， 如果你只是写一些简单的脚本，去做一些一次性任务，用面向过程的方式很合适，但如果你要处理的任务是复杂的，且需要不断迭代和维护的，那还是用面向对象比较好。 面向对象编程(Object-Oriented Programming)OOP编程是利用“类”和“对象”来创建各种模型来实现对真实世界的描述，使用面向对象编程的原因一方面是因为它可以使程序的维护和扩展变得更简单，并且可以大大提高程序开发效率 ，另外，基于面向对象的程序可以使它人更加容易理解你的代码逻辑，从而使团队开发变得更从容。 面向对象的几个核心特性： Class 类 一个类即是对一类拥有相同属性的对象的抽象、蓝图、原型。在类中定义了这些对象的都具备的属性（variables(data)）、共同的方法 前面我们写到“人狗大战”中dog、person其实就是类 Object 对象 一个对象即是一个类的实例化后实例，一个类必须经过实例化后方可在程序中调用，一个类可以实例化多个对象，每个对象亦可以有不同的属性，就像人类是指所有人，每个人是指具体的对象，人与人之前有共性，亦有不同 前面我们写到“人狗大战”中d1、d2、p1、p2其实就是对象 Encapsulation 封装 在类中对数据的赋值、内部调用对外部用户是透明的，这使类变成了一个胶囊或容器，里面包含着类的数据和方法 Inheritance 继承 一个类可以派生出子类，在这个父类里定义的属性、方法自动被子类继承 Polymorphism 多态 多态是面向对象的重要特性,简单点说:“一个接口，多种实现”，指一个基类中派生出了不同的子类，且每个子类在继承了同样的方法名的同时又对父类的方法做了不同的实现，这就是同一种事物表现出的多种形态。 编程其实就是一个将具体世界进行抽象化的过程，多态就是抽象化的一种体现，把一系列具体事物的共同点抽象出来, 再通过这个抽象的事物, 与不同的具体事物进行对话。 对不同类的对象发出相同的消息将会有不同的行为。比如，你的老板让所有员工在九点钟开始工作, 他只要在九点钟的时候说：“开始工作”即可，而不需要对销售人员说：“开始销售工作”，对技术人员说：“开始技术工作”, 因为“员工”是一个抽象的事物, 只要是员工就可以开始工作，他知道这一点就行了。至于每个员工，当然会各司其职，做各自的工作。 多态允许将子类的对象当作父类的对象使用，某父类型的引用指向其子类型的对象,调用的方法是该子类型的方法。这里引用和调用方法的代码编译前就已经决定了,而引用所指向的对象可以在运行期间动态绑定。 面向对象vs面向过程总结面向过程的程序设计的核心是过程（流水线式思维），过程即解决问题的步骤，面向过程的设计就好比精心设计好一条流水线，考虑周全什么时候处理什么东西。 优点是：极大的降低了写程序的复杂度，只需要顺着要执行的步骤，堆叠代码即可。 缺点是：一套流水线或者流程就是用来解决一个问题，代码牵一发而动全身。 面向对象的程序设计的核心是对象（上帝式思维），要理解对象为何物，必须把自己当成上帝，上帝眼里世间存在的万物皆为对象，不存在的也可以创造出来。面向对象的程序设计好比如来设计西游记，如来要解决的问题是把经书传给东土大唐，如来想了想解决这个问题需要四个人：唐僧，沙和尚，猪八戒，孙悟空，每个人都有各自的特征和技能（这就是对象的概念，特征和技能分别对应对象的属性和方法），然而这并不好玩，于是如来又安排了一群妖魔鬼怪，为了防止师徒四人在取经路上被搞死，又安排了一群神仙保驾护航，这些都是对象。然后取经开始，师徒四人与妖魔鬼怪神仙互相缠斗着直到最后取得真经。如来根本不会管师徒四人按照什么流程去取。 面向对象的程序设计的 优点：解决了程序的扩展性。对某一个对象单独修改，会立刻反映到整个体系中，如对游戏中一个人物参数的特征和技能修改都很容易。 缺点：可控性差，无法向面向过程的程序设计流水线式的可以很精准的预测问题的处理流程与结果，面向对象的程序一旦开始就由对象之间的交互解决问题，即便是上帝也无法预测最终结果。于是我们经常看到一个游戏人某一参数的修改极有可能导致阴霸的技能出现，一刀砍死3个人，这个游戏就失去平衡。 应用场景：需求经常变化的软件，一般需求的变化都集中在用户层，互联网应用，企业内部软件，游戏等都是面向对象的程序设计大显身手的好地方。 面向对象程序设计类的定义1help(list) Help on class list in module builtins: class list(object) | list() -&gt; new empty list | list(iterable) -&gt; new list initialized from iterable&apos;s items | | Methods defined here: | | __add__(self, value, /) | Return self+value. | | __contains__(self, key, /) | Return key in self. | | __delitem__(self, key, /) | Delete self[key]. | | __eq__(self, value, /) | Return self==value. | | __ge__(self, value, /) | Return self&gt;=value. | | __getattribute__(self, name, /) | Return getattr(self, name). | | __getitem__(...) | x.__getitem__(y) &lt;==&gt; x[y] | | __gt__(self, value, /) | Return self&gt;value. | | __iadd__(self, value, /) | Implement self+=value. | | __imul__(self, value, /) | Implement self*=value. | | __init__(self, /, *args, **kwargs) | Initialize self. See help(type(self)) for accurate signature. | | __iter__(self, /) | Implement iter(self). | | __le__(self, value, /) | Return self&lt;=value. | | __len__(self, /) | Return len(self). | | __lt__(self, value, /) | Return self&lt;value. | | __mul__(self, value, /) | Return self*value.n | | __ne__(self, value, /) | Return self!=value. | | __new__(*args, **kwargs) from builtins.type | Create and return a new object. See help(type) for accurate signature. | | __repr__(self, /) | Return repr(self). | | __reversed__(...) | L.__reversed__() -- return a reverse iterator over the list | | __rmul__(self, value, /) | Return self*value. | | __setitem__(self, key, value, /) | Set self[key] to value. | | __sizeof__(...) | L.__sizeof__() -- size of L in memory, in bytes | | append(...) | L.append(object) -&gt; None -- append object to end | | clear(...) | L.clear() -&gt; None -- remove all items from L | | copy(...) | L.copy() -&gt; list -- a shallow copy of L | | count(...) | L.count(value) -&gt; integer -- return number of occurrences of value | | extend(...) | L.extend(iterable) -&gt; None -- extend list by appending elements from the iterable | | index(...) | L.index(value, [start, [stop]]) -&gt; integer -- return first index of value. | Raises ValueError if the value is not present. | | insert(...) | L.insert(index, object) -- insert object before index | | pop(...) | L.pop([index]) -&gt; item -- remove and return item at index (default last). | Raises IndexError if list is empty or index is out of range. | | remove(...) | L.remove(value) -&gt; None -- remove first occurrence of value. | Raises ValueError if the value is not present. | | reverse(...) | L.reverse() -- reverse *IN PLACE* | | sort(...) | L.sort(key=None, reverse=False) -&gt; None -- stable sort *IN PLACE* | | ---------------------------------------------------------------------- | Data and other attributes defined here: | | __hash__ = None123456789class Dog: # 类名首字母要大写，驼峰体 d_type = \"金毛\" # 公共属性，又称类变量 def say_hi(self): # 类的方法，必须带一个self参数，代表实例本身 print(\"hello , I am a dog,my type is \",self.d_type) # 想调用类里的属性，都要加上self.d1 = Dog() # 生成一个狗的实例d2 = Dog() # 生成一个狗的实例d1.say_hi() # 调用狗这个类的方法 实例.方法d2.say_hi()print(d1.d_type) # 调用Dog类的公共属性 hello , I am a dog,my type is 金毛 hello , I am a dog,my type is 金毛 金毛以上代码就是定义好了Dog这个类，相当于先生成了一个模板，接下来生成了2个实例d1, d2，相当于2条有血有肉的狗被创造出来了。 d_type是类变量，是Dog类下所有实例共有的属性，它存在Dog类本身的内存里。你可以查看d1.d_type,d2.d_type的内存地址，指向的是同一处。 除了共有属性，还有私有属性，比如每条狗的名字、年龄都不一样。 1234567891011121314class Dog: # 类名首字母要大写，驼峰体 d_type = \"金毛\" # 公共属性，又称类变量 def __init__(self,name,age,master): # 初始化函数，只要一实例化，就会自动执行 print('初始化这个实例....',name) self.name = name # self.name 就是实例自己的变量 self.age = age self.master = master def say_hi(self): # 类的方法，必须带一个self参数，代表实例本身 print(\"hello , I am a dog,my type is \",self.d_type) # 想调用类里的属性，都要加上self.d1 = Dog(\"毛毛\",2,\"Alex\") # 生成一个狗的实例d2 = Dog(\"大黄\",3,\"Jack\") # 生成一个狗的实例d1.say_hi() # 调用狗这个类的方法d2.say_hi()print(d2.name, d2.age, d2.master) # 调用实例的变量 初始化这个实例.... 毛毛 初始化这个实例.... 大黄 hello , I am a dog,my type is 金毛 hello , I am a dog,my type is 金毛 大黄 3 Jack我们并没有调用init(self,….)，但它会自动执行，因为它叫初始化函数，就是在实例化的时候，用来初始化一些数据的，比如初始化你实例的名字、年龄等属性。 self就是代表实例本身，你实例化时Python会自动把这个实例本身通过self参数传进去。 self在实例化时自动将对象/实例本身传给init的第一个参数，你也可以给它起个别的名字，但是正常人都不会这么做，因为你瞎改别人就不认识。 属性引用类的公共属性引用（类名.属性）123456class Dog: # 类名首字母要大写，驼峰体 d_type = \"京巴\" # 公共属性，又称类变量 def say_hi(self): print(\"hello , I am a dog,my type is \",self.d_type) print(Dog.d_type) # 查看Dog的d_type属性print(Dog.say_hi) # 引用Dog的say_hi方法，注意只是引用，不是调用 京巴 &lt;function Dog.say_hi at 0x10f045488&gt;实例属性引用(实例名.属性)123456789101112class Dog: # 类名首字母要大写，驼峰体 d_type = \"京巴\" # 公共属性，又称类变量 def __init__(self,name,age,master): # 初始化函数，只要一实例化，就会自动执行 self.name = name # self.name 就是实例自己的变量 self.age = age self.master = master def say_hi(self): print(\"hello , I am a dog,my type is \",self.d_type) d2 = Dog(\"二蛋\",3,\"Jack\") # 生成一个狗的实例d2.say_hi() # 调用狗这个类的方法print(d2.name, d2.age, d2.master) # 调用实例的属性print(d2.d_type) # 注意通过实例也可以调用类的公共属性 hello , I am a dog,my type is 京巴 二蛋 3 Jack 京巴练习设计一个类Person，生成若干实例，在终端输出如下信息 小明，10岁，男，喜欢打篮球 小红，13岁，女，喜欢跳芭蕾 老李，40岁，男，喜欢吹牛 老张… 12 12345class Point: '''Represent a point in 2-D space.'''a = Point()print(Point)print(a) &lt;class &apos;__main__.Point&apos;&gt; &lt;__main__.Point object at 0x10f0536d8&gt;12","link":"/2020/05/26/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%BC%BA%E5%8C%96-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"title":"Python基础1","text":"0.引言值和类型 值（value）是程序操作的最基本的东西，如一个字母或者数字 值属于不同的数据类型（type） Python中的数据类型： 基本数据类型 数字（整型（长整型）、浮点型、复数） 布尔型 容器数据类型 字符串 列表 元组 字典 集合 123age = 10height = 150.5name = 'Tom' 1.基本数据类型1.1 整型123a = 1031#可以看出变量a 的值及 a 的类（class）是 intprint(a, type(a)) Python 中万物皆对象（object），「整数」也不例外 只要是对象，就有相应的属性（attributes）与方法（methods） 通过dir(x)和 help(x)可以看出 x 对应的对象里可用的属性和方法 1dir(int) 1help(int) 123# bit_length函数返回整数对应的二进制值的长度# a = 1031，对应二进制值为 1000000011，长度为 11a.bit_length() 1234567891011#长整形（了解）#在python2中（python3中没有长整形的概念）'''num=2Ltype(num) &lt;type 'long'&gt;'''#复数（了解） x=1-2jprint(x.real)print(x.imag) 1.2 浮点型12print(1, type(1))print(1., type(1.)) 浮点型（float）数就是实数 如果想保留浮点型的小数点后 n 位，可以用 decimal 包里的 Decimal 对象和 getcontext()方法来实现： 1234import decimalfrom decimal import Decimal# Decimal 对象的默认精度值是28 位decimal.getcontext() 12d = Decimal(1) / Decimal(3)d 123decimal.getcontext().prec = 4e = Decimal(1) / Decimal(3)print(e) 内置函数int()与float() int()函数用于将一个字符串或数字转换为整数 float() 函数用于将整数和字符串转换成浮点数 1help(int()) 1234x = int(10.5)print(x)y = int('101',2)print(y) 1.3 布尔型布尔（boolean）型变量只能取两个值，True 和 False 当把布尔型变量用在数字运算中，用 1 和 0 代表True 和 False 1234T = TrueF = Falseprint(T + 2)print(F - 8) 除了直接给变量赋值True 和 False，还可以用 bool(x)来创建变量 其中 x 可以是： *基本类型：整型、浮点型、布尔型 *容器类型：字符、元组、列表、字典和集合 12345# 基本类型# bool 作用在基本类型变量：x 只要不是整型 0、浮点型 0.0，bool(x) 就是True，其余就是 Falseprint(type(0), bool(0), bool(2))print(type(0.), bool(0.), bool(1.5))print(type(True), bool(False), bool(True)) 1234567# 容器类型# bool 作用在容器类型变量：x 只要不是空的变量，bool(x) 就是 True，其余就是 Falseprint( type(''), bool( '' ), bool( 'python' ) )print( type(()), bool( () ), bool( (10,) ) )print( type([]), bool( [] ), bool( [1,2] ) )print( type({}), bool( {} ), bool( {'a':1, 'b':2} ) )print( type(set()), bool( set() ), bool( {1,2} ) ) 1.4 身份运算type()方法可以查看一个数据的类型，那么如何判断一个数据是否是某个数据类型呢？Python 提供了身份运算符 is 和 is not。 12a = 34type(a) is int 12b = 12.5type(b) is not float 注意 is 运算也是比较，is比较的是id，而==比较的是值。 毫无疑问，id若相同则值肯定相同，而值相同id则不一定相同 12345x = 123y = 123#x == yprint(id(x))print(id(y)) 12345m = 1234n = 1234m is nprint(id(m))print(id(n)) 123456a = 5b = aprint(id(a))print(id(b))a = 6print(b) 2.容器数据类型整型、浮点型和布尔型都可以看成是单独数据，而这些数据都可以放在一个容器里得到一个「容器类型」的数据，比如： 字符 (str) 是一容器的字节 char，注意 Python 里面没有 char 类型的数据，可以把单字符的 str 当做 char。 元组 (tuple)、列表 (list)、字典 (dict) 和集合 (set) 是一容器的任何类型变量。 2.1 字符串字符串用于处理文本 (text) 数据，用「单引号 ’」和「双引号 “」来定义都可以。 1234t1 = 'i love python!'print( t1, type(t1) )t2 = \"I love Python!\"print( t2, type(t2) ) 字符串方法字符中常见的内置方法 (可以用 dir(str) 来查看) 有： 12# capitalize()：大写句首的字母t1.capitalize() 12# title()：每个单词首字母大写t1.title() 12# upper()：所有字母大写t1.upper() 12# lower()：所有字母小写t2.lower() 12# split()：拆分字符串（默认用空格拆分）t1.split() 123# find(x)：找到给定词 x 在句中的索引，找不到返回 -1print( t1.find('love') )print( t1.find('like') ) 123# replace(x, y)：把句中 x 替代成 yt3 = t2.replace( 'love Python', 'hate R' )print(t3) 123# strip(x)：删除句首或句末含 x 的部分print( 'http://www.python.org'.strip('htp:/') )print( 'http://www.python.org'.strip('.org') ) 索引和切片Python 里面索引和切片有三个特点： *从 0 开始 (和 C 一样) *切片通常写成 start:end 这种形式，包括「start 索引」对应的元素，不包括「end索引」对应的元素。 索引值可正可负，正索引从 0 开始，从左往右；负索引从 -1 开始，从右往左。使用负数索引时，会从最后一个元素开始计数。最后一个元素的位置编号是 -1。 123456s = 'Python'print(s)#print( s[2:4] )print( s[-5:-2] )print( s[2] )print( s[-1] ) 成员运算inPython支持成员运算符，可用于字符串、列表和元组 in：如果在指定的序列中找到值返回 True，否则返回 False。 not in：如果在指定的序列中没有找到值返回 True，否则返回 False。 1'py' in 'python' 正则表达式正则表达式 (regular expression) 主要用于识别字符串中符合某种模式的部分，什么叫模式呢？看下面的例子： 123456input = \"\"\"'06/18/2019 13:00:00', 100, '1st';'06/18/2019 13:30:00', 110, '2nd';'06/18/2019 14:00:00', 120, '3rd'\"\"\"input 假如想把上面字符串中的「时间」的模式来抽象的表示出来，对照着具体表达式’06/18/2019 13:00:00’ 来看，我们发现该字符串有以下规则： 1.开头和结束都有个单引号 ‘ 2.里面有多个 0-9 数字 3.里面有多个正斜线/ 和冒号 : 4.还有一个空格 因此我们用下面这样的模式： 12import repattern = re.compile(\"'[0-9/:\\s]+'\") 再看这个抽象模式表达式 ‘[0-9/:\\s]+’，里面符号的意思如下： 最外面的两个单引号 ‘ 代表该模式以它们开始和结束 中括号 [] 用来概括该模式涵盖的所有类型的字节 0-9 代表数字类的字节/ 代表正斜线 : 代表冒号 \\s 代表空格 [ ] 外面的加号 + 代表 [ ] 里面的字节出现至少 1 次 有了模式 pattern，我们来看看是否能把字符串中所有符合 pattern 的日期表达式都找出来。 1pattern.findall(input) 关于正则表达式的内容可以进一步参考：https://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html 2.2 元组创建元组「元组」定义语法为： (元素1, 元素2, …, 元素n) 关键点是「小括号 ()」和「逗号 ,」 小括号把所有元素绑在一起 逗号将每个元素一一分开 1234t1 = (1, 10.31, 'python')t2 = 1, 10.31, 'python'print( t1, type(t1) )print( t2, type(t2) ) 创建元组可以用小括号 ()，也可以什么都不用，为了可读性，建议还是用 ()。 此外对于含单个元素的元组，务必记住要多加一个逗号： 12print( type( ('OK') ) ) # 没有逗号 , print( type( ('OK',) ) ) # 有逗号 , 也可以创建二维元组： 12nested = (1, 10.31, 'python'), ('data', 11)nested 索引和切片元组中可以用整数来对它进行索引 (indexing) 和切片 (slicing) 不严谨的讲，前者是获取单个元素，后者是获取一组元素。 123456#((1, 10.31, 'python'), ('data', 11))# 索引print(nested[0])print( nested[0][0], nested[0][1], nested[0][2] )# 切片nested[0][0:2] 不可更改元组有不可更改 (immutable) 的性质，因此不能直接给元组的元素赋值，例如： 12t = ('OK', [1, 2], True)t[2] = False 但是只要元组中的元素可更改 (mutable)，那么我们可以直接更改其元素，注意这跟赋值其元素不同。 123# t[1] 是列表，其内容可以更改，因此用 append 在列表后加一个值没问题t[1].append(3)print(t) 内置方法元组大小和内容都不可更改，因此只有 count 和 index 两种方法。 123t = (1, 10.31, 'python')print( t.count('python') )print( t.index(10.31) ) 这两个方法返回值都是 1，但意思完全不同 count(‘python’) 是记录在元组 t 中该元素出现几次，显然是 1 次 index(10.31) 是找到该元素在元组 t 的索引，显然是 1 元组拼接元组拼接 (concatenate) 有两种方式，用「加号 +」和「乘号 *」，前者首尾拼接，后者复制拼接。 1234a = (1, 10.31, 'python') + ('data', 11) + ('OK',)b = (1, 10.31, 'python') * 2print(a)print(b) 解压元组解压 (unpack) 一维元组：有几个元素左边括号定义几个变量 123t = (1, 10.31, 'python')(a, b, c) = tprint( b ) 解压二维元组：按照元组里的元组结构来定义变量 123t = (1, 10.31, ('OK','python'))(a, b, (c,d)) = tprint( a, b, c, d ) 如果你只想要元组其中几个元素，用通配符（wildcard）「*」，在计算机语言中代表一个或多个元素。 12345t = 1, 2, 3, 4, 5# 把多个元素丢给了 rest 变量a, b, *rest, c = tprint( a, b, c )print( rest ) 如果你根本不在乎 rest 变量，那么就用通配符「*」加上下划线「_」： 12a, b, *_ = tprint( a, b ) 元组的优缺点优点：占内存小，安全，创建遍历速度比列表快，可一赋多值。 缺点：不能添加和更改元素。 12%timeit [1, 2, 3, 4, 5]%timeit (1, 2, 3, 4, 5) 2.3 列表创建列表列表」定义语法为 [元素1, 元素2, …, 元素n] 关键点是「中括号 [ ]」和「逗号 ,」 中括号把所有元素绑在一起 逗号将每个元素一一分开 12l = [1, 10.31,'python']print(l, type(l)) 不像元组，列表内容可更改 (mutable)，因此附加 (append, extend)、插入 (insert)、删除 (remove, pop) 这些操作都可以使用。 1234567# 附加(append, extend)# append 是追加，把一个东西整体添加在列表后l.append([4, 3])print( l )# extend 是扩展，把一个东西里的所有元素添加在列表后l.extend([1.5, 2.0, 'OK'])print( l ) 123# 插入l.insert(1, 'abc') # 在索引位置之前插入内容l 1234567# 删除# remove指定具体要删除的元素l.remove('python') # pop指定一个索引位置，比如 3，删除 l[3] 并返回出来p = l.pop(3) print( p )print( l ) 索引切片123l = [7, 2, 9, 10, 1, 3, 7, 2, 0, 1]print(l[1:5])print(l[-4:]) 列表可更改，因此可以用切片来赋值。 12l[2:4] = [999, 1000]l 切片的通用写法是 start : stop : step 这三个在特定情况下都可以省去，我们来看看四种情况： 1234# 情况 1 - start :(以 step 为 1 (默认) 从编号 start 往列表尾部切片)print( l )print( l[3:] )print( l[-4:] ) 1234# 情况 2 - : stop(以 step 为 1 (默认) 从列表头部往编号 stop 切片)print( l )print( l[:6] )print( l[:-4] ) 1234# 情况 3 - start : stop(以 step 为 1 (默认) 从编号 start 往编号 stop 切片)print( l )print( l[2:4] )print( l[-5:-1] ) 1234567# 情况 4 - start : stop : step(以具体的 step 从编号 start 往编号 stop 切片)print( l )print( l[1:5:2] )print( l[:5:2] )print( l[1::2] )print( l[::2] )print( l[::-1] ) 列表拼接和元组拼接一样， 列表拼接也有两种方式，用「加号 +」和「乘号 *」，前者首尾拼接，后者复制拼接 1234a = [1, 10.31, 'python'] + ['data', 11] + ['OK']b = [1, 10.31, 'python'] * 2print(a)print(b) 列表优缺点优点：灵活好用，可索引、可切片、可更改、可附加、可插入、可删除。 缺点：相比 tuple 创建和遍历速度慢，占内存。此外查找和插入时间较慢。 练习1.有列表data=[[‘张三’,’男’,[175.5,71.0]],[‘李四’,’女’,[165.0,55.5]]]，分别取出列表中的名字，性别，身高、体重值并按如下格式输出：“张三，男，身高175.5cm，体重71.0kg。”，每条数据一行。 2.双色球 先让用户依次选择6个红球（1-32），再选择2个蓝球（1-16），最后打印输出用户选择的球号（按从小到大的顺序）。注意确保用户不能选择重复的，选择的数不能超出范围。 1234data=[['张三','男',[175.5,71.0]],['李四','女',[165.0,55.5]]]#for lst in data: print('{}，{}，身高{}cm，体重{}kg。'.format(data[0][0],data[0][1],data[0][2][0],data[0][2][1])) 2.4 字典创建字典「字典」定义语法为 {元素1, 元素2, …, 元素n} 其中每一个元素是一个「键值对」- 键:值 (key:value) 关键点是「大括号 {}」,「逗号 ,」和「冒号 :」 大括号把所有元素绑在一起 逗号将每个键值对一一分开 冒号将键和值分开 12345678d = {'Name' : 'Tencent','Country' : 'China','Industry' : 'Technology','Code': '00700.HK','Price' : '361 HKD'}print( d, type(d) ) 内置方法字典里最常用的三个内置方法就是 keys(), values() 和 items()，分别是获取字典的键、值、对。 123print( list(d.keys()),'\\n' )print( list(d.values()), '\\n' )print( list(d.items()) ) 在字典上也有添加、获取、更新、删除等操作。 123# 添加d['Headquarter'] = 'Shen Zhen'd 12345# 获取# 查看腾讯的股价是多少 (两种方法都可以)print( d['Price'] )print( d.get('Price') )d.get('price') 1234# 更新#更新腾讯的股价到 359 港币d['Price'] = '359 HKD'd 1234# 删除#去掉股票代码 (code)del d['Code']d 123#或像列表里的 pop() 函数，删除行业 (industry) 并返回出来。print( d.pop('Industry') )d 不可更改键字典里的键是不可更改的，因此只有那些不可更改的数据类型才能当键，比如整数 (虽然怪怪的)、浮点数 (虽然怪怪的)、布尔 (虽然怪怪的)、字符、元组 (虽然怪怪的)，而列表却不行，因为它可更改。 1234567d = {2 : 'integer key',10.31 : 'float key',True : 'boolean key',('OK',3) : 'tuple key'}d 有个地方要注意下，True其实和整数 1 是一样的，由于键不能重复，当你把 2 该成 1时，你会发现字典只会取其中一个键 1234567d = {1 : 'integer key',10.31 : 'float key',True : 'boolean key',('OK',3) : 'tuple key'}d 如何快速判断一个数据类型 X 是不是可更改的呢？两种方法： 麻烦方法：用 id(X) 函数，对 X 进行某种操作，比较操作前后的 id，如果不一样，则 X 不可更改，如果一样，则 X 可更改。 便捷方法：用 hash(X)，只要不报错，证明 X 可被哈希，即不可更改，反过来不可被哈希，即可更改。 1234i = 1print( id(i) )i = i + 2print( id(i) ) 整数 i 在加 1 之后的 id 和之前不一样，因此加完之后的这个 i (虽然名字没变)，但是不是加前的那个 i 了，因此整数是不可更改的。 1234l = [1, 2]print( id(l) )l.append('Python')print( id(l) ) 列表 l 在附加 ‘Python’ 之后的 id 和之前一样，因此列表是可更改的。 用 hash() 函数的在字符 s，元组 t 和列表 l 上的运行结果： 1hash('Name') 1hash( (1,2,'Python') ) 1hash( [1,2,'Python'] ) 字典优缺点优点：查找和插入速度快 缺点：占内存大 字典的典型应用：计数器给你一个字符串，请统计每个字母出现的次数。 有几种可能实现的方法： 创建 26 个变量，每个变量对应一个字母。然后遍历字符串，对每个字符，增加相应的计数器…… 创建 一个包含 26 个元素的列表。每个变量对应一个字母…… …… 使用字典： 建立一个字典，以字符作为键，以计数器作为相应的值。 遍历字符串，第一次遇到某个字符时，在字典中添加对应的项。 123456789101112def histogram(s): d = dict() for c in s: if c not in d: d[c] = 1 # c:1 else: d[c] += 1 return ddef main(): h = input('请输入一个字符串：') print(histogram(h))main() 请输入一个字符串：AAVC {&apos;A&apos;: 2, &apos;V&apos;: 1, &apos;C&apos;: 1}优化：字典的 get 方法接收一个键以及一个默认值，如果键在字典中，get 返回对应的值，否则返回它的默认值。试试使用get方法优化代码，去掉if语句。 123d={'a':1}d['d']+=d.get('d',1)d --------------------------------------------------------------------------- KeyError Traceback (most recent call last) &lt;ipython-input-12-e75ddc4596af&gt; in &lt;module&gt; 1 d={&apos;a&apos;:1} ----&gt; 2 d[&apos;d&apos;]+=d.get(&apos;d&apos;,1) 3 d KeyError: &apos;d&apos;12345678910111213def histogram(s): d = dict() for c in s: #if c not in d: # d[c] = 1 #else: # d[c] += 1 d[c]=d.get(c,0)+1 return ddef main(): h = input('请输入一个字符串：') print(histogram(h))main() 请输入一个字符串：aabc {&apos;a&apos;: 2, &apos;b&apos;: 1, &apos;c&apos;: 1}这个程序还有两个问题: 同一个字母大小写会被分别统计。 输出结果不够友好：乱序、以字典的形式输出。尝试修改程序，解决以上两个问题。 提示：内置函数sorted可以对字典的键进行排序。 12da = {'a':5,'c':3,'b':4}sorted(da) 2.5 集合创建集合「集合」有两种定义语法，第一种是 {元素1, 元素2, …, 元素n} 关键点是「大括号 {}」和「逗号 ,」 大括号把所有元素绑在一起 逗号将每个元素一一分开 第二种是用 set() 函数，把列表或元组转换成集合。 set( 列表 或 元组 ) 1234A = set(['u', 'd', 'ud', 'du', 'd', 'du'])B = {'d', 'dd', 'uu', 'u'}print( A )print( B ) 从 A 的结果发现集合的两个特点：无序 (unordered) 和唯一 (unique)。由于 set 存储的是无序集合，所以我们没法通过索引来访问，但是可以判断一个元素是否在集合中。 1B[1] 1set('apple') 1'u' in B 内置方法用 set 的内置方法就把它当成是数学上的集合 123# 并集print( A.union(B) ) # All unique elements in A or Bprint( A | B ) # A OR B 123# 交集print( A.intersection(B) ) # All elements in both A and Bprint( A &amp; B ) # A AND B 12345# 差集print( A.difference(B) ) # Elements in A but not in Bprint( A - B ) # A MINUS Bprint( B.difference(A) ) # Elements in B but not in Aprint( B - A ) # B MINUS A 123# 对称差集print( A.symmetric_difference(B) ) # All elements in either A or B, but not bothprint( A ^ B ) # A XOR B 集合优缺点优点：不用判断重复的元素 缺点：不能存储可变对象 练习有如下两个集合，pythons是报名python课程的学员名字集合，linuxs是报名linux课程的学员名字集合 pythons={‘alex’,’egon’,’yuanhao’,’wupeiqi’,’gangdan’,’biubiu’} linux={‘wupeiqi’,’oldboy’,’gangdan’} 求出即报名python又报名linux课程的学员名字集合 求出所有报名的学生名字集合 求出只报名python课程的学员名字 求出没有同时这两门课程的学员名字集合 3 条件语句与迭代循环在编写程序时，我们需要： 在不同条件下完成不同动作，条件语句（conditional statement）赋予程序选择的能力。 重复地完成某些动作，迭代循环（iterative loop）赋予程序重复能力。 3.1 条件语句条件语句有以下四种格式： 1.if语句 2.if-else语句 3.if-elif-else语句 4.嵌套（nested）语句 12if x &gt; 0: print( 'x is positive' ) 1234if x % 2 == 0: print( 'x is even' )else : print( 'x is odd' ) 123456if x &lt; y: print( 'x is less than y' )elif x &gt; y: print( 'x is greater than y' )else: print( 'x and y are equal' ) 1234567if x == y: print( 'x and y are equal' )else: if x &lt; y: print( 'x is less than y' ) else: print( 'x is greater than y' ) 3.2 迭代循环Python中有「while循环」和「for循环」。 while循环非常简单，只要条件为True就一直重复。 一般来说，在「while循环」中，迭代的次数事先时不知道的。 12345n = 5while n &gt; 0: print(n) n = n-1print('I love Python') break与continue12345#break用于退出本层循环while True: print(\"123\") break print(\"456\") 12345#continue用于退出本次循环while True: print(\"123\") continue print(\"456\") while …else 语句与其它语言else 一般只与if 搭配不同，在Python 中还有个while …else 语句，while 后面的else 作用是指，当while 循环正常执行完，中间没有被break 中止的话，就会执行else后面的语句 12345678count = 0while count &lt;= 5 : count += 1 print(\"Loop\",count)else: print(\"循环正常执行完啦\")print(\"-----out of while loop ------\") 12345678910#如果执行过程中被break啦，就不会执行else的语句啦count = 0while count &lt;= 5 : count += 1 if count == 3:break print(\"Loop\",count)else: print(\"循环正常执行完啦\")print(\"-----out of while loop ------\") 更多时候我们希望事先知道循环的次数，比如在列表、元组、字典等容器类型数据中遍历一遍，在每个元素层面上做点事情。这时候就需要「for循环」了。 1234language = ['Python', 'R', 'Matlab', 'C++']for language in language: print('I love', language)print('Done!') 「for循环」的通用形式为： for a in A: do somthing with a其中A是个可迭代数据（str, list, tuple, dic, set），a是A中的每个元素。 12 在遍历中，还有一个enumerate() 函数需要介绍一下： enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。 enumerate() 函数的语法如下： enumerate(sequence, [start=0]) 1234language = ['Python', 'R', 'Matlab', 'C++']for i,language in enumerate(language): print(i,'I love', language)print('Done!') 0 I love Python 1 I love R 2 I love Matlab 3 I love C++ Done!123456language = ['Python', 'R', 'Matlab', 'C++']i = 1for item in language: print(i,language[i]) i += 1print('Done!') enumerate() 函数应用实例： 要统计文件的行数，可以这样写： count = len(open(filepath, ‘r’).readlines()) 这种方法简单，但是可能比较慢，当文件比较大时甚至不能工作。 可以利用enumerate()： count = 0for index, line in enumerate(open(filepath,’r’))： count += 1 练习1.编写一个程序进行用户登录验证，如果用户名和密码与程序设置一致则提示“登录成功”，否则提示“用户名或密码错误，请重试！”，一共有三次机会重试，超出三次程序结束。 2.打印金字塔，金字塔的层数可以用参数控制max_level = 5 @ max_level = 1,空格4（5-n），@1（2n-1） @@@ max_level = 2,空格3，@3 5-2 @@@@@ max_level = 3,空格2，@5 5-3 @@@@@@@ max_level = 4,空格1，@7@@@@@@@@@ max_level = 5,空格0，@9","link":"/2020/05/26/Python%E5%9F%BA%E7%A1%801/"},{"title":"Python基础2","text":"函数1 什么是函数？ 2 为什么要用函数？ 3 函数的分类：内置函数与自定义函数 4 如何自定义函数 语法 定义有参数函数，及有参函数的应用场景 定义无参数函数，及无参函数的应用场景 定义空函数，及空函数的应用场景 5 调用函数 如何调用函数 函数的返回值 函数参数的应用：形参和实参，位置参数，关键字参数，默认参数，args，*kwargs 6 匿名函数 7 高阶函数 8 解析式 1 什么是函数想象生活中的例子，修理工需要事先在工具箱里面准备好锤子、扳手、钳子等工具，然后遇到锤钉子的场景，拿来锤子用就可以，而无需临时再制造一把锤子。 修理工===&gt;程序员 具备某一功能的工具===&gt;函数 要想使用工具，需要事先准备好，然后拿来就用且可以重复使用要想用函数，需要先定义，再使用 定义: 函数是指将一组语句的集合通过一个名字(函数名)封装起来，要想执行这个函数，只需调用其函数名即可 2 为什么要用函数解决三个问题： 1 代码的组织结构不清晰，可读性差 2 遇到重复的功能只能重复编写实现代码，代码冗余 3 功能需要扩展时，需要找出所有实现该功能的地方修改，无法统一管理且维护难度极大 3 函数的分类：内置函数与自定义函数1 内置（built-in）函数 为了方便我们的开发，针对一些简单的功能，python解释器已经为我们定义好了的函数叫内置函数。 对于内置函数，我们可以拿来就用而无需事先定义，如：len(),sum(),max() 2 自定义函数 很明显内置函数所能提供的功能是有限的，这就需要我们自己根据需求，事先定制好我们自己的函数来实现某种功能，以后，在遇到应用场景时，调用自定义的函数即可。 4 如何自定义函数1234567#语法def 函数名(参数1,参数2,参数3,...): '''注释''' 函数体 return 返回的值#函数名要能反映其意义 File &quot;&lt;ipython-input-1-3a09a5c2bd40&gt;&quot;, line 2 def 函数名(参数1,参数2,参数3,...): ^ SyntaxError: invalid syntax123456789101112131415def auth(user:str,password:str)-&gt;int: ''' auth function :param user: 用户名 :param password: 密码 :return: 认证结果 ''' if user == 'egon' and password == '123': return 1# print(auth.__annotations__) #{'user': &lt;class 'str'&gt;, 'password': &lt;class 'str'&gt;, 'return': &lt;class 'int'&gt;}user=input('用户名&gt;&gt;: ').strip()pwd=input('密码&gt;&gt;: ').strip()res=auth(user,pwd)print(res) 用户名&gt;&gt;: egon 密码&gt;&gt;: 123 1函数使用的原则先定义，再调用 函数即“变量”，“变量”必须先定义后引用。未定义而直接引用函数，就相当于在引用一个不存在的变量名 12345#测试一def foo(): print('from foo') bar()foo() #报错 from foo --------------------------------------------------------------------------- NameError Traceback (most recent call last) &lt;ipython-input-18-37242c8c0654&gt; in &lt;module&gt;() 3 print(&apos;from foo&apos;) 4 bar() ----&gt; 5 foo() #报错 &lt;ipython-input-18-37242c8c0654&gt; in foo() 2 def foo(): 3 print(&apos;from foo&apos;) ----&gt; 4 bar() 5 foo() #报错 NameError: name &apos;bar&apos; is not defined1234567#测试二def bar(): print('from bar')def foo(): print('from foo') bar()foo() #正常 from foo from bar12345678#测试三def foo(): print('from foo') bar() def bar(): print('from bar')foo() #会报错吗? from foo from bar123456789101112'''结论:函数的使用,必须遵循原则:先定义,后调用我们在使用函数时,一定要明确地区分定义阶段和调用阶段'''#定义阶段def foo(): print('from foo') bar()def bar(): print('from bar')#调用阶段foo() 函数在定义阶段都干了哪些事？只检测语法，不执行代码 也就说，语法错误在函数定义阶段就会检测出来，而代码的逻辑错误只有在执行时才会知道。 定义函数的三种形式 无参：应用场景仅仅只是执行一些操作，比如与用户交互，打印 有参：需要根据外部传进来的参数，才能执行相应的逻辑，比如统计长度，求最大值最小值 空函数：设计代码结构 123456789101112131415#定义阶段def tell_tag(tag,n): #有参数 print(tag*n)def tell_msg(): #无参数 print('hello world!')#调用阶段tell_tag('*',12)tell_msg()tell_tag()#结论：#1、定义时无参，意味着调用时也无需传入参数#2、定义时有参，意味着调用时则必须传入参数 ************ hello world! --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-22-f7552c45df36&gt; in &lt;module&gt;() 9 tell_tag(&apos;*&apos;,12) 10 tell_msg() ---&gt; 11 tell_tag() 12 13 #结论： TypeError: tell_tag() missing 2 required positional arguments: &apos;tag&apos; and &apos;n&apos;123456789101112131415161718192021222324252627282930# 空函数def auth(user,password): ''' auth function :param user: 用户名 :param password: 密码 :return: 认证结果 ''' pass def get(filename): ''' :param filename: :return: ''' pass def put(filename): ''' :param filename: :return: ''' def ls(dirname): ''' :param dirname: :return: ''' pass #程序的体系结构立见 练习尝试使用函数完成以下代码实现的效果。 123456789print('+ - - - - + - - - - +')print('| | |')print('| | |')print('| | |')print('+ - - - - + - - - - +')print('| | |')print('| | |')print('| | |')print('+ - - - - + - - - - +') + - - - - + - - - - + | | | | | | | | | + - - - - + - - - - + | | | | | | | | | + - - - - + - - - - +进一步优化程序，编写一个函数 print_table(rows, cols, width)实现表格打印，其中参数rows代表表格的行数，参数rows代表表格的列数，参数 width代表单元格的宽度（即两个+中间有几个-）。 5 调用函数5.1 调用函数函数的调用：函数名加括号 1）先找到名字 2）根据名字调用代码 5.2 函数返回值函数外部的代码要想获取函数的执行结果，就可以在函数里用return语句把结果返回。 函数在执行过程中只要遇到return语句，就会停止执行并返回结果，也可以理解为 return 语句代表着函数的结束。 如果未在函数中指定return,那这个函数的返回值为None。 12345- 无return-&gt;None- return 1个值-&gt;返回1个值- return 逗号分隔多个值-&gt;元组 什么时候该有返回值？ 调用函数，经过一系列的操作，最后要拿到一个明确的结果，则必须要有返回值 通常有参函数需要有返回值，输入参数，经过计算，得到一个最终的结果 什么时候不需要有返回值？ 调用函数，仅仅只是执行一系列的操作，最后不需要得到什么结果，则无需有返回值 通常无参函数不需要有返回值 5.3 全局与局部变量123456name = \"c\"def change_name(): name = \"Jerry\" print(\"After change:\", name)change_name()print(\"在外面看看name改了么?\",name) After change: Jerry 在外面看看name改了么? c为什么在函数内部改了name的值后， 在外面print的时候却没有改呢？ 因为这两个name根本不是一回事 在函数中定义的变量称为局部变量，在程序的一开始定义的变量称为全局变量。 全局变量作用域(即有效范围)是整个程序，局部变量作用域是定义该变量的函数。 变量的查找顺序是局部变量&gt;全局变量 当全局变量与局部变量同名时，在定义局部变量的函数内，局部变量起作用；在其它地方全局变量起作用。 在函数里是不能直接修改全局变量的 如果想在函数里修改全局变量怎么办？ 1234567name = \"Tom\"def change_name(): global name #声明一个全局变量 name = \"Jerry\" print(\"After change:\", name)change_name()print(\"在外面看看name改了么?\", name) After change: Jerry 在外面看看name改了么? Jerryglobal name的作用就是要在函数里声明全局变量 name，意味着最上面的name = “Tom”即使不写，程序最后面的print也可以打印name 传递列表、字典、集合产生的现象： 1234567d = {\"name\":\"Alex\",\"age\":26,\"hobbie\":\"运动\"}l = [\"Rebeeca\",\"Katrina\",\"Rachel\"]def change_data(info,name): info[\"hobbie\"] = \"学习\" name.append(\"XiaoHong\")change_data(d,l)print(d,l) {&apos;name&apos;: &apos;Alex&apos;, &apos;age&apos;: 26, &apos;hobbie&apos;: &apos;学习&apos;} [&apos;Rebeeca&apos;, &apos;Katrina&apos;, &apos;Rachel&apos;, &apos;XiaoHong&apos;]不是说不能在函数里改全局变量么，为什么改了呢？ 其实， 程序只是把d这个dict的内存地址传给了change_data函数，把dict比作鱼缸，里面的key,value比作缸里装的鱼。现在只是把鱼缸丢给了函数，这个鱼缸本身你不能改，但是里面的鱼可以。 相当于只是传了一个对这个d的引用关系给到函数的形参。这样是为了减少内存的浪费，因为如果这个dict比较大，传一次到函数里就要copy一份新的值的话，效率太低了。 5.4 函数的参数形参（parameter）与实参（argument） 形参变量 只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只在函数内部有效。函数调用结束返回主调用函数后则不能再使用该形参变量 实参 可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参。因此应预先给实参赋值。 123456def calc(x, y): res = x ** y return resa, b = 5, 8c = calc(a, b)print(c) 390625Python 的函数具有非常灵活多样的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。从简到繁的参数形态如下： 1.位置参数 (positional argument) 2.默认参数 (default argument) 3.可变参数 (variable argument) 4.关键字参数 (keyword argument) 5.命名关键字参数 (name keyword argument) 6.参数组合 每种参数形态都有自己对应的应用。 位置参数 123456def calc(x, y): res = x ** y return resa, b = 5, 8c = calc(a, b)print(c) 390625「位置参数」是按照参数的位置进行关联的。 123456def calc(x, y): res = x ** y return resa, b = 8, 5c = calc(a, b)print(c) 32768默认参数 arg2 = v - 默认参数 = 默认值，调用函数的时候，默认参数已经有值，如果不传值就使用默认值，不会报错。 123456789def stu_register(name,age,country,course): print(\"----注册学生信息------\") print(\"姓名:\",name) print(\"age:\",age) print(\"国籍:\",country) print(\"课程:\",course)stu_register(\"王\",22,\"CN\",\"python_devops\")stu_register(\"张\",21,\"CN\",\"linux\")stu_register(\"刘\",25,\"CN\",\"linux\") 我们发现 country 这个参数 基本都 是”CN”, 就像我们在网站上注册用户，像国籍这种信息，你不填写，默认就会是 中国， 这就是通过默认参数实现的，把country变成默认参数非常简单： 1234567def stu_register(name,age,course,country=\"CN\"): print(\"----注册学生信息------\") print(\"姓名:\",name) print(\"age:\",age) print(\"国籍:\",country) print(\"课程:\",course)stu_register(\"刘\",25,\"linux\") File &quot;&lt;ipython-input-29-383d67d71eea&gt;&quot;, line 1 def stu_register(name,age,country=&quot;CN&quot;,course): ^ SyntaxError: non-default argument follows default argument 注意：默认函数一定要放在位置参数后面，不然程序会报错。 1help(print) Help on built-in function print in module builtins: print(...) print(value, ..., sep=&apos; &apos;, end=&apos;\\n&apos;, file=sys.stdout, flush=False) Prints the values to a stream, or to sys.stdout by default. Optional keyword arguments: file: a file-like object (stream); defaults to the current sys.stdout. sep: string inserted between values, default a space. end: string appended after the last value, default a newline. flush: whether to forcibly flush the stream.12345678910# 「默认参数」可以是多个def instrument3( id, ntl=1, curR='CNY' ): print( 'id:', id ) print( 'notional:', ntl ) print( 'reporting currency:', curR)#instrument3( 'MM1001', 100, 'USD' )# 有时在调用函数时，我们会记不住参数的顺序，比如 ntl 和 curR 的位置写反了#instrument3( 'MM1001', 'USD', 100 )# 在调用参数把它的「关键字」也带上，我们就可以随便调换参数的顺序。#instrument3( 'MM1001', curR='USD', ntl=100 ) 可变参数 若你的函数在定义时不确定用户想传入多少个参数，就可以使用可变参数 *args - 可变参数，可以是从零个到任意个，自动组装成元组。 12345678def stu_register(name,age,*args): # *args 会把多传入的参数变成一个元组形式 print(name,age,args)stu_register(\"Alex\",22)#输出#Alex 22 () #后面这个()就是args,只是因为没传值,所以为空stu_register(\"Jack\",32,\"CN\",\"Python\")#输出# Jack 32 ('CN', 'Python') Alex 22 () Jack 32 (&apos;CN&apos;, &apos;Python&apos;)可变参数用两种方式传入 直接传入，func(1, 2, 3) 先组装列表或元组，再通过 args 传入，func([1, 2, 3]) 或 func(*(1, 2, 3)) 关键字参数 **kw - 关键字参数，可以是从零个到任意个，自动组装成字典。 「可变参数」和「关键字参数」的同异： 可变参数允许传入零个到任意个参数，它们在函数调用时自动组装为一个元组 (tuple) 关键字参数允许传入零个到任意个参数，它们在函数内部自动组装为一个字典 (dict) 12345678def stu_register(name,age,*args,**kwargs): print(name,age,args,kwargs)stu_register(\"Alex\",22)#输出#Alex 22 () {}#后面这个{}就是kwargs,只是因为没传值,所以为空stu_register(\"Jack\",32,\"CN\",\"Python\",sex=\"Male\",province=\"ShanDong\")#输出# Jack 32 ('CN', 'Python') {'province': 'ShanDong', 'sex': 'Male'} Alex 22 () {} Jack 32 (&apos;CN&apos;, &apos;Python&apos;) {&apos;sex&apos;: &apos;Male&apos;, &apos;province&apos;: &apos;ShanDong&apos;}12345# 除了直接传入多个参数之外，还可以将所有参数先组装成字典 Conv，用以「**Conv」的形式传入函数# Conv 是个字典，前面加个通配符 ** 是拆散字典，把字典的键值对传入函数中DCF = (1, 2, 3, 4, 5)Conv = {'dc':'act/365', 'bdc':'following'}instrument( 'MM1001', 10, 'EUR', *DCF, **Conv ) 命名关键字参数对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。 如果要限制关键字参数的名字，就可以用「命名关键字参数」 1print('hello', end = '') 123456789101112# 用户希望 ctp 是个关键字参数def instrument( id, ntl=1, curR='CNY', *, ctp, **kw ): print( 'id:', id ) print( 'notional:', ntl ) print( 'reporting currency:', curR ) print( 'counterparty:', ctp ) print( 'keyword:', kw)#instrument( 'MM1001', 100, 'EUR', dc='act/365', ctp='GS' )# 使用命名关键字参数时，要特别注意不能缺少参数名。# 如果没有写参数名 ctp， 'GS' 被当成「位置参数」# 原函数只有 3 个位置函数，现在调用了 4 个，因此程序会报错instrument( 'MM1001', 100, 'EUR','GS', dc='act/365' ) --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-37-ae11fd8aa430&gt; in &lt;module&gt;() 10 # 如果没有写参数名 ctp， &apos;GS&apos; 被当成「位置参数」 11 # 原函数只有 3 个位置函数，现在调用了 4 个，因此程序会报错 ---&gt; 12 instrument( &apos;MM1001&apos;, 100, &apos;EUR&apos;,&apos;GS&apos;, dc=&apos;act/365&apos; ) TypeError: instrument() takes from 1 to 3 positional arguments but 4 were given参数组合在 Python 中定义函数，可以用位置参数、默认参数、可变参数、命名关键字参数和关键字参数 这 5 种参数中的 4 个都可以一起使用，但是注意，参数定义的顺序必须是： 位置参数、默认参数、可变参数和关键字参数。 位置参数、默认参数、命名关键字参数和关键字参数。 要注意定义可变参数和关键字参数的语法： *args 是可变参数，args 接收的是一个 tuple **kw 是关键字参数，kw 接收的是一个 dict 命名关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。 定义命名关键字参数不要忘了写分隔符 *，否则定义的是位置参数。 练习1、写函数，计算传入字符串中【数字】、【字母】、【空格] 以及 【其他】的个数 提示：字符串的isdigit()、isalpha()、isspace()方法。 2、写函数，检查传入列表的长度，如果大于2，那么仅保留前两个长度的内容，并将新内容返回给调用者。 3、写函数，检查获取传入列表或元组对象的所有奇数位索引对应的元素，并将其作为新列表返回给调用者。 4、写函数，检查字典的每一个value的长度,如果大于2，那么仅保留前两个长度的内容，并将新内容返回给调用者。dic = {“k1”: “v1v1”, “k2”: [11,22,33,44]}PS:字典中的value只能是字符串或列表 5、写函数，计算传入数字参数的和。（动态传参） 6、写函数，传入n个数，返回字典{‘max’:最大值,’min’:最小值} 6 匿名函数 解释一下函数里面的各个部分： lambda - 定义匿名函数的关键词。 argument_list - 函数参数，它们可以是位置参数、默认参数、关键字参数，和正规函数里的参数类型一样。 ：- 冒号，在函数参数和表达式中间要加个冒号。 expression - 函数表达式，输入函数参数，输出一些值。 注意： lambda 函数没有所谓的函数名 (function_header)，这也是它为什么叫匿名函数。 123# lambda x, y: x*y；函数输入是 x 和 y，输出是它们的积 x*yfunc = lambda x, y: x*yfunc(2, 3) 6123# lambda *args: sum(args)；输入是任意个数的参数，输出是它们的和func = lambda *args: sum(args)func( 1, 2, 3, 4, 5 ) 15123# lambda **kwargs: 1；输入是任意键值对参数，输出是 1func = lambda **kwargs: 1func( name='Steven', age='36' ) 为什么使用lambda 函数? Lambda函数主要在短时间内需要一个函数时才使用。当你想要将函数作为参数传递给高阶函数(即以其他函数作为参数的函数)时，通常使用这种方法。 12345678# 下面的例子演示了在其他函数中使用匿名函数# testfunc函数传入一个参数，将它与一个未知数相乘。def testfunc(num): return lambda x : x * numresult1 = testfunc(10)result2 = testfunc(1000)print(result1(9))print(result2(9)) 90 9000对于 lambda 函数，我们应该避免过用 (overuse) 它或误用 (misuse) 它： 误用情况：如果用 lambda 函数只是为了赋值给一个变量，用 def 的正规函数。 过用情况：如果一个函数很重要，它需要一个正规的名字。 7 高阶函数高阶函数 (high-order function) 在函数化编程 (functional programming) 很常见，主要有两种形式： 参数是函数 (map, filter, reduce) 返回值是函数 (closure, partial, currying) Map, Filter, ReducePython 里面的 map, filter 和 reduce 属于第一种高阶函数，参数是函数。 首先看看 map, filter 和 reduce 的语法： map(函数 f, 序列 x)：对序列 x 中每个元素依次执行函数 f，将 f(x) 组成一个「map 对象」返回 (可以将其转换成 list 或 set) filter(函数 f, 序列 x)：对序列 x 中每个元素依次执行函数 f，将 f(x) 为 True 的结果组成一个「filter 对象」返回 (可以将其转换成 list 或 set) reduce(函数 f, 序列 x)：对序列 x 的第一个和第二个元素执行函数 f，得到的结果和序列 x 的下一个元素执行函数 f，一直遍历完的序列 x 所有元素。 12345# 用 map 函数对列表每个元素平方lst = (1, 2, 3, 4, 5)map_iter = map( lambda x: x**2, lst )print( map_iter )print( list(map_iter) ) &lt;map object at 0x7f8ead10bd68&gt; [1, 4, 9, 16, 25]在 map 函数中 第一个参数是一个计算平方的「匿名函数」 第二个参数是列表，即该「匿名函数」作用的对象 注意 map_iter 是 map 函数的返回对象 (它是一个迭代器)，想要将其内容显示出来，需要用 list 将其转换成「列表」形式。 12345# filter 函数，顾名思义就是筛选函数# 使用filter 函数把刚才列表中的奇数筛选出来filter_iter = filter(lambda n: n % 2 == 1, lst)print( filter_iter )print( list(filter_iter) ) &lt;filter object at 0x10aab0e80&gt; [1, 3, 5]在 filter 函数中 第一个参数是一个识别奇数的「匿名函数」 第二个参数是列表，即该「匿名函数」作用的对象 同样，filter_iter 作为 filter 函数的返回对象，也是一个迭代器，想要将其内容显示出来，需要用 list 将其转换成「列表」形式。 1234# reduce 函数，顾名思义就是累积函数# 用reduce 函数把一组数减少 (reduce) 到一个数from functools import reducereduce( lambda x,y: x*y, lst ) 120在 reduce 函数中 第一个参数是一个求和相邻两个元素的「匿名函数」 第二个参数是列表，即该「匿名函数」作用的对象 在 reduce 函数的第三个参数还可以赋予一个初始值： 1reduce( lambda x,y: x+y, lst, 100 ) 115闭包 (closure)Python 里面的闭包 (closure) 属于第二种高阶函数，返回值是函数。下面是一个闭包函数： 123456789def make_counter(init): counter = [init] def inc(): counter[0] += 1 def dec(): counter[0] -= 1 def get(): return counter[0] def reset(): counter[0] = init return inc, dec, get, reset 此函数的作用是做一个计数器，可以： 用增加子函数 inc() 加一秒 用减少子函数 dec() 减一秒 用获取子函数 get() 看秒数 用重置子函数 reset() 回原点 12345inc, dec, get, reset = make_counter(0)inc()inc()inc()get() 312dec()get() 212reset()get() 0属于第二类 (返回值是函数) 的高阶函数还有「偏函数」和「柯里化」 8 解析式8.1 框架解析式（comprehension）是将一个可迭代对象转换成另一个可迭代对象的工具。 容器类型数据（str、tuple、list、dict、set）都是可迭代对象。 第一个可迭代对象：可以使任何容器类型数据。 第二个可迭代对象：取决于什么类型的解析式： 列表解析式：可迭代对象是list 字典解析式：可迭代对象是dict 集合解析式：可迭代对象是set 123456# list comprehension[值 for 元素 in 可迭代对象 if 条件]# dict comprehension{键值对 for 元素 in 可迭代对象 if 条件}# set comprehension{值 for 元素 in 可迭代对象 if 条件} complex这些解析式都有： for…in…：for循环 if：if条件解析式就是为了把「带条件的for循环」简化成一行代码的。 8.2 列表解析式问题：如何从一个整数列表中把奇数筛选出来再乘以2？ 1234567# 用带if的for循环lst = [1, 2, 3, 4, 5]odds = []for n in lst: if n % 2 == 1: odds.append(n*2)odds [2, 6, 10]1234# 用列表解析式lst = [1, 2, 3, 4, 5]odds = [n*2 for n in lst if n % 2 == 1]odds 列表解析式只用一行代码就解决问题了，但似乎不直观，我们分析一下： 可以把「for 循环」到「解析式」的过程想像成一个「复制-粘贴」的过程： 1.将「for 循环」的新列表复制到「解析式」里 2.将 append 里面的表达式 n * 2 复制到新列表里 3.复制循环语句 for n in lst 到新列表里，不要最后的冒号 4.复制条件语句 if n%2 == 1 到新列表里，不要最后的冒号 把上面具体的例子推广到一般的例子，从「for 循环」到「列表解析式」的过程如下： 8.3 其他解析式我们可以把「列表解析式」那一套举一反三的用到其他解析式上，用下面两图理解一下「字典解析式」和「集合解析式」。 前面我们说过“ Python 不建议使用 map 和 filter。而是用「解析式」优雅地替代 map 和 filter 。” 我们来看看为什么： 1234#「列表解析式」实现「在列表中先找出奇数再乘以 2」[ n*2 for n in lst if n%2 == 1]#「map/filter」实现「在列表中先找出奇数再乘以 2」list( map(lambda n: n*2, filter(lambda n: n%2 == 1, lst)) ) 实例：用解析式将二维元组里每个元素提取出来并存储到一个列表中。 1tup = ((1, 2, 3), (4, 5, 6), (7, 8, 9)) 先遍历第一层元组，用 for t in tup，然后遍历第二层元组，用 for x in t，提取每个 x 并”放在“列表中，用 [ ]。 代码如下： 12flattened = [x for t in tup for x in t]flattened 总结函数包括正规函数 (用 def) **和匿名函数 (用 lambda)**，函数的参数形态也多种多样，有位置参数、默认参数、可变参数、关键字参数、命名关键字参数。 匿名函数主要用在高阶函数中，高阶函数的参数可以是函数 (Python 里面内置 map/filter/reduce 函数)，返回值也可以是参数 (闭包、偏函数、柯里化函数)。 解析式并没有解决新的问题，只是以一种更加简洁，可读性更高的方式解决老的问题。解析式可以把「带 if 条件的 for 循环」用一行程序表达出来，也可以实现 map 加 filter 的功能。 12345678910111213141516171819202122232425262728293031323334# here is a mostly-straightforward solution to the# two-by-two version of the grid.def do_twice(f): f() f()def do_four(f): do_twice(f) do_twice(f)def print_beam(): print('+ - - - -', end=' ')def print_post(): print('| ', end=' ')def print_beams(): do_twice(print_beam) print('+')def print_posts(): do_twice(print_post) print('|')def print_row(): print_beams() do_four(print_posts)def print_grid(): do_twice(print_row) print_beams()print_grid() + - - - - + - - - - + | | | | | | | | | | | | + - - - - + - - - - + | | | | | | | | | | | | + - - - - + - - - - +123456789101112131415161718192021222324252627282930313233343536373839404142def one_four_one(f, g, h): f() do_four(g) h()def print_plus(): print('+', end=' ')def print_dash(): print('-', end=' ')def print_bar(): print('|', end=' ')def print_space(): print(' ', end=' ')def print_end(): print()def nothing(): \"do nothing\"def print1beam(): one_four_one(nothing, print_dash, print_plus)def print1post(): one_four_one(nothing, print_space, print_bar)def print4beams(): one_four_one(print_plus, print1beam, print_end)def print4posts(): one_four_one(print_bar, print1post, print_end)def print_row(): one_four_one(nothing, print4posts, print4beams)def print_grid(): one_four_one(print4beams, print_row, nothing)print_grid() + - - - - + - - - - + - - - - + - - - - + | | | | | | | | | | | | | | | | | | | | + - - - - + - - - - + - - - - + - - - - + | | | | | | | | | | | | | | | | | | | | + - - - - + - - - - + - - - - + - - - - + | | | | | | | | | | | | | | | | | | | | + - - - - + - - - - + - - - - + - - - - + | | | | | | | | | | | | | | | | | | | | + - - - - + - - - - + - - - - + - - - - + 123def even_items(seq): return seq[1::2]print(even_items([1,2,3,4,5,6,7])) [2, 4, 6]1234def my_sum(*num): return sum(num)out = my_sum(1, 2, 3, 4)print(out) 10内置函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139abs # 求绝对值 all #Return True if bool(x) is True for all values x in the iterable.If the iterable is empty, return True.any #Return True if bool(x) is True for any x in the iterable.If the iterable is empty, return False.ascii #Return an ASCII-only representation of an object,ascii(“中国”) 返回”‘\\u4e2d\\u56fd’”bin #返回整数的2进制格式 bool # 判断一个数据结构是True or False, bool({}) 返回就是False, 因为是空dictbytearray # 把byte变成 bytearray, 可修改的数组bytes # bytes(“中国”,”gbk”) callable # 判断一个对象是否可调用 chr # 返回一个数字对应的ascii字符 ， 比如chr(90)返回ascii里的’Z’classmethod #面向对象时用，现在忽略compile #py解释器自己用的东西，忽略complex #求复数，一般人用不到copyright #没用credits #没用delattr #面向对象时用，现在忽略dict #生成一个空dictdir #返回对象的可调用属性divmod #返回除法的商和余数 ，比如divmod(4,2)，结果(2, 0) enumerate #返回列表的索引和元素，比如 d = [“alex”,”jack”]，enumerate(d)后，得到(0, ‘alex’) (1, ‘jack’)eval #可以把字符串形式的list,dict,set,tuple,再转换成其原有的数据类型。 exec #把字符串格式的代码，进行解义并执行，比如exec(“print(‘hellworld’)”)，会解义里面的字符串并执行exit #退出程序filter #对list、dict、set、tuple等可迭代对象进行过滤， filter(lambda x:x&gt;10,[0,1,23,3,4,4,5,6,67,7])过滤出所有大于10的值float #转成浮点format #没用frozenset #把一个集合变成不可修改的getattr #面向对象时用，现在忽略globals #打印全局作用域里的值 hasattr #面向对象时用，现在忽略hash #hash函数help hex #返回一个10进制的16进制表示形式,hex(10) 返回’0xa’id #查看对象内存地址input intisinstance #判断一个数据结构的类型，比如判断a是不是fronzenset, isinstance(a,frozenset) 返回 True or Falseissubclass #面向对象时用，现在忽略iter #把一个数据结构变成迭代器，讲了迭代器就明白了lenlistlocalsmap # map(lambda x:x**2,[1,2,3,43,45,5,6,]) 输出 [1, 4, 9, 1849, 2025, 25, 36]max # 求最大值 memoryview # 一般人不用，忽略 min # 求最小值 next # 生成器会用到，现在忽略 object #面向对象时用，现在忽略oct # 返回10进制数的8进制表示open ord # 返回ascii的字符对应的10进制数 ord(‘a’) 返回97，printproperty #面向对象时用，现在忽略quitrange repr #没什么用reversed # 可以把一个列表反转round #可以把小数4舍5入成整数 ，round(10.15,1) 得10.2setsetattr #面向对象时用，现在忽略slice # 没用sorted staticmethod #面向对象时用，现在忽略strsum #求和,a=[1, 4, 9, 1849, 2025, 25, 36],sum(a) 得3949super #面向对象时用，现在忽略tuple type vars #返回一个对象的属性，面向对象时就明白了zip #可以把2个或多个列表拼成一个， a=[1, 4, 9, 1849, 2025, 25, 36]，b = [“a”,”b”,”c”,”d”]， 12","link":"/2020/05/26/Python%20%E5%9F%BA%E7%A1%80%202/"},{"title":"面向对象程序设计2","text":"人狗大战我们接到了一个游戏开发任务，需要开发一款叫做“人狗大战”的游戏。 思考： 人狗大战，那至少需要2个角色，一个是人， 一个是狗，且人和狗都有不同的技能，比如人可以打狗， 狗可以咬人，怎么描述这种不同的角色和他们的功能呢？ 角色 狗：名字、种类、攻击力、生命值… 人：名字、年龄 动作 狗咬人 人打狗 1234567891011121314151617181920# 用字典定义角色#一条狗dog = { \"name\":\"大黄\", \"d_type\":\"金毛\", \"attack_val\":70, \"hp\":100}# 用函数定义动作def bite(person): person.hp -= 30 # 另一条狗# 参数相同，值不同dog2 = { \"name\":\"老黑\", \"d_type\":\"藏獒\", \"attack_val\":150, \"hp\":150} 为了避免重复，可以把字典也写成函数： 12345678910111213def dog(name, d_type, attack_val, hp): data = { \"name\":name, \"d_type\":d_type, \"attack_val\":attack_val, \"hp\":hp } return datad1 = dog(\"大黄\",\"金毛\",70,70)d2 = dog(\"老黑\",\"藏獒\",150,150)print(d1)print(d2) {&apos;name&apos;: &apos;大黄&apos;, &apos;d_type&apos;: &apos;金毛&apos;, &apos;attack_val&apos;: 70, &apos;hp&apos;: 70} {&apos;name&apos;: &apos;老黑&apos;, &apos;d_type&apos;: &apos;藏獒&apos;, &apos;attack_val&apos;: 150, &apos;hp&apos;: 150}可以这样认为： 函数dog就是一个狗的模板 变量d1和d2就是基于这个模板创建的实体 我们还可以把狗的attack_val和与狗的d_type关联起来，给hp设置一个默认值： 123456789101112131415161718attack_vals = { \"金毛\":70, \"藏獒\":150}def dog(name, d_type): data = { \"name\":name, \"d_type\":d_type, \"hp\":100 } if d_type in attack_vals: data[\"attack_val\"] = attack_vals[d_type] return datad1 = dog(\"大黄\",\"金毛\")d2 = dog(\"老黑\",\"藏獒\")print(d1)print(d2) {&apos;name&apos;: &apos;大黄&apos;, &apos;d_type&apos;: &apos;金毛&apos;, &apos;hp&apos;: 100, &apos;attack_val&apos;: 70} {&apos;name&apos;: &apos;老黑&apos;, &apos;d_type&apos;: &apos;藏獒&apos;, &apos;hp&apos;: 100, &apos;attack_val&apos;: 150}接下来照方抓药，把人的角色也写出来： 12345678910111213141516def person(name, age): data = { \"name\":name, \"age\":age, \"hp\":100 } if age &gt; 18: data[\"attack_val\"] = 50 else: data[\"attack_val\"] = 30 return datap1 = person('Tom', 25)p2 = person('Jerry', 17)print(p1)print(p2) {&apos;name&apos;: &apos;Tom&apos;, &apos;age&apos;: 25, &apos;hp&apos;: 100, &apos;attack_val&apos;: 50} {&apos;name&apos;: &apos;Jerry&apos;, &apos;age&apos;: 17, &apos;hp&apos;: 100, &apos;attack_val&apos;: 30}接下来是动作，动作可以让角色直接产生交互： 123456def dog_bite(dog_obj, person_obj): person_obj['hp'] -= dog_obj['attack_val'] print('狗[%s]咬了人[%s]一口，人生命值减少[%s]，生命值还剩[%s]...'%(dog_obj['name'], person_obj['name'], dog_obj['attack_val'], person_obj['hp'])) 合并一下，完成交互： 1234567891011121314151617181920212223242526272829303132333435attack_vals = { \"金毛\":70, \"藏獒\":150}def dog(name, d_type): data = { \"name\":name, \"d_type\":d_type, \"hp\":100 } if d_type in attack_vals: data[\"attack_val\"] = attack_vals[d_type] return datadef person(name, age): data = { \"name\":name, \"age\":age, \"hp\":100 } if age &gt; 18: data[\"attack_val\"] = 50 else: data[\"attack_val\"] = 30 return datadef dog_bite(dog_obj, person_obj): person_obj['hp'] -= dog_obj['attack_val'] print('狗[%s]咬了人[%s]一口，人生命值减少[%s]，生命值还剩[%s]...'%(dog_obj['name'], person_obj['name'], dog_obj['attack_val'], person_obj['hp']))p1 = person('Tom', 25)p2 = person('Jerry', 17)d1 = dog(\"大黄\",\"金毛\")d2 = dog(\"老黑\",\"藏獒\")dog_bite(d1, p1) 狗[大黄]咬了人[Tom]一口，人生命值减少[70]，生命值还剩[30]...练习：在刚才程序的基础上增加一个人打狗的函数person_beat 接下来考虑一个问题： 如果我们在交互的时候不小心写错了会怎么样？ 比如：dog_bite(p1, d1) 123456def person_beat(person_obj, dog_obj): dog_obj['hp'] -= person_obj['attack_val'] print('人[%s]打了狗[%s]一棒，狗生命值减少[%s]，生命值还剩[%s]...'%(person_obj['name'], dog_obj['name'], person_obj['attack_val'], dog_obj['hp'])) 1234567891011121314151617181920212223242526272829303132333435attack_vals = { \"金毛\":70, \"藏獒\":150}def dog(name, d_type): data = { \"name\":name, \"d_type\":d_type, \"hp\":100 } if d_type in attack_vals: data[\"attack_val\"] = attack_vals[d_type] return datadef person(name, age): data = { \"name\":name, \"age\":age, \"hp\":100 } if age &gt; 18: data[\"attack_val\"] = 50 else: data[\"attack_val\"] = 30 return datadef dog_bite(dog_obj, person_obj): person_obj['hp'] -= dog_obj['attack_val'] print('狗[%s]咬了人[%s]一口，人生命值减少[%s]，生命值还剩[%s]...'%(dog_obj['name'], person_obj['name'], dog_obj['attack_val'], person_obj['hp']))p1 = person('Tom', 25)p2 = person('Jerry', 17)d1 = dog(\"大黄\",\"金毛\")d2 = dog(\"老黑\",\"藏獒\")dog_bite(p1, d1) 狗[Tom]咬了人[大黄]一口，人生命值减少[50]，生命值还剩[50]...按照正常逻辑，dog_bite只能狗来使用，person_beat只能人使用，否则就会产生逻辑混乱。 怎么解决这个问题呢？ 我们可以增加一些判断，也可以把dog_bite函数写到dog函数内部… 总结其实上面写的代码，就是面向对象的代码。 我们在设计角色时，为了让一个角色可以变成多个实体对象，设计了一个基础模板，只要传入不同参数，就会产生不同的狗。 这代表我们已经开始切换成上帝视角看事情 ，上帝视角就是面向对象编程的视角，上帝要造世界万物，他肯定不是一个一个的造出来，他肯定是设计出一个个的物种的模板，然后通过模子批量批一个个的实体造出来。造出来的实体各有特色，属性、功能都不尽相同，这些人之间会发生什么关系 ，上帝懒的管，上帝只控制大局。 面向过程 VS 面向对象编程范式编程是程序员用特定的语法+数据结构+算法组成的代码来告诉计算机如何执行任务的过程 ，一个程序是程序员为了得到一个任务结果而编写的一组指令的集合。 正所谓条条大路通罗马，实现一个任务的方式有很多种不同的方式， 对这些不同的编程方式的特点进行归纳总结出来的编程方式类别，即为编程范式。 不同的编程范式本质上代表对各种类型的任务采取的不同的解决问题的思路， 大多数语言只支持一种编程范式，当然也有些语言可以同时支持多种编程范式。 两种最重要的编程范式分别是面向过程编程和面向对象编程。 面向过程编程(Procedural Programming) Procedural programming uses a list of instructions to tell the computer what to do step-by-step. 面向过程编程依赖procedures，一个procedure包含一组要被进行计算的步骤， 面向过程又被称为top-down languages， 就是程序从上到下一步步执行，一步步从上到下，从头到尾的解决问题 。基本设计思路就是程序一开始是要着手解决一个大的问题，然后把一个大问题分解成很多个小问题或子过程，这些子过程再执行的过程再继续分解直到小问题足够简单到可以在一个小步骤范围内解决。 举个典型的面向过程的例子， 有个需求是对网站日志进行分析，生成邮件报告，整个流程分以下几步： 到各台服务器上收集日志，因为有多台网站服务器，共同对外提供服务 对日志进行各种维度分析，比如pv,uv, 来源地区、访问的设备等 生成报告，发送邮件 代码如下: 1234567891011121314151617181920212223# 1 整合日志def collect_logs(): print(\"log on server A ,get access.log\") print(\"log on server B ,get access.log\") print(\"log on server C ,get access.log\") print(\"combine logs in to one file\")# 2 日志分析def log_analyze(log_file): print(\"pv、uv分析....\") print(\"用户来源分析....\") print(\"访问的设备来源分析....\") print(\"页面停留时间分析....\") print(\"入口页面分析....\")# 3 生成报告并发送def send_report(report_data): print(\"connect email server...\") print(\"send email....\")def main(): collect_logs() log_analyze('my_db') send_report()if __name__ == '__main__': main() 这样做的问题也是显而易见的，就是如果你要对程序进行修改，对你修改的那部分有依赖的各个部分你都也要跟着修改， 举个例子，如果程序开头你设置了一个变量值为1 ，但如果其它子过程依赖这个值为1的变量才能正常运行，那如果你改了这个变量，那这个子过程你也要修改，假如又有一个其它子程序依赖这个子过程 ，那就会发生一连串的影响，随着程序越来越大，这种编程方式的维护难度会越来越高。 所以我们一般认为， 如果你只是写一些简单的脚本，去做一些一次性任务，用面向过程的方式很合适，但如果你要处理的任务是复杂的，且需要不断迭代和维护的，那还是用面向对象比较好。 面向对象编程(Object-Oriented Programming)OOP编程是利用“类”和“对象”来创建各种模型来实现对真实世界的描述，使用面向对象编程的原因一方面是因为它可以使程序的维护和扩展变得更简单，并且可以大大提高程序开发效率 ，另外，基于面向对象的程序可以使它人更加容易理解你的代码逻辑，从而使团队开发变得更从容。 面向对象的几个核心特性： Class 类 一个类即是对一类拥有相同属性的对象的抽象、蓝图、原型。在类中定义了这些对象的都具备的属性（variables(data)）、共同的方法 前面我们写到“人狗大战”中dog、person其实就是类 Object 对象 一个对象即是一个类的实例化后实例，一个类必须经过实例化后方可在程序中调用，一个类可以实例化多个对象，每个对象亦可以有不同的属性，就像人类是指所有人，每个人是指具体的对象，人与人之前有共性，亦有不同 前面我们写到“人狗大战”中d1、d2、p1、p2其实就是对象 Encapsulation 封装 在类中对数据的赋值、内部调用对外部用户是透明的，这使类变成了一个胶囊或容器，里面包含着类的数据和方法 Inheritance 继承 一个类可以派生出子类，在这个父类里定义的属性、方法自动被子类继承 Polymorphism 多态 多态是面向对象的重要特性,简单点说:“一个接口，多种实现”，指一个基类中派生出了不同的子类，且每个子类在继承了同样的方法名的同时又对父类的方法做了不同的实现，这就是同一种事物表现出的多种形态。 编程其实就是一个将具体世界进行抽象化的过程，多态就是抽象化的一种体现，把一系列具体事物的共同点抽象出来, 再通过这个抽象的事物, 与不同的具体事物进行对话。 对不同类的对象发出相同的消息将会有不同的行为。比如，你的老板让所有员工在九点钟开始工作, 他只要在九点钟的时候说：“开始工作”即可，而不需要对销售人员说：“开始销售工作”，对技术人员说：“开始技术工作”, 因为“员工”是一个抽象的事物, 只要是员工就可以开始工作，他知道这一点就行了。至于每个员工，当然会各司其职，做各自的工作。 多态允许将子类的对象当作父类的对象使用，某父类型的引用指向其子类型的对象,调用的方法是该子类型的方法。这里引用和调用方法的代码编译前就已经决定了,而引用所指向的对象可以在运行期间动态绑定。 面向对象vs面向过程总结面向过程的程序设计的核心是过程（流水线式思维），过程即解决问题的步骤，面向过程的设计就好比精心设计好一条流水线，考虑周全什么时候处理什么东西。 优点是：极大的降低了写程序的复杂度，只需要顺着要执行的步骤，堆叠代码即可。 缺点是：一套流水线或者流程就是用来解决一个问题，代码牵一发而动全身。 面向对象的程序设计的核心是对象（上帝式思维），要理解对象为何物，必须把自己当成上帝，上帝眼里世间存在的万物皆为对象，不存在的也可以创造出来。面向对象的程序设计好比如来设计西游记，如来要解决的问题是把经书传给东土大唐，如来想了想解决这个问题需要四个人：唐僧，沙和尚，猪八戒，孙悟空，每个人都有各自的特征和技能（这就是对象的概念，特征和技能分别对应对象的属性和方法），然而这并不好玩，于是如来又安排了一群妖魔鬼怪，为了防止师徒四人在取经路上被搞死，又安排了一群神仙保驾护航，这些都是对象。然后取经开始，师徒四人与妖魔鬼怪神仙互相缠斗着直到最后取得真经。如来根本不会管师徒四人按照什么流程去取。 面向对象的程序设计的 优点：解决了程序的扩展性。对某一个对象单独修改，会立刻反映到整个体系中，如对游戏中一个人物参数的特征和技能修改都很容易。 缺点：可控性差，无法向面向过程的程序设计流水线式的可以很精准的预测问题的处理流程与结果，面向对象的程序一旦开始就由对象之间的交互解决问题，即便是上帝也无法预测最终结果。于是我们经常看到一个游戏人某一参数的修改极有可能导致阴霸的技能出现，一刀砍死3个人，这个游戏就失去平衡。 应用场景：需求经常变化的软件，一般需求的变化都集中在用户层，互联网应用，企业内部软件，游戏等都是面向对象的程序设计大显身手的好地方。 面向对象程序设计类的定义1help(list) Help on class list in module builtins: class list(object) | list() -&gt; new empty list | list(iterable) -&gt; new list initialized from iterable&apos;s items | | Methods defined here: | | __add__(self, value, /) | Return self+value. | | __contains__(self, key, /) | Return key in self. | | __delitem__(self, key, /) | Delete self[key]. | | __eq__(self, value, /) | Return self==value. | | __ge__(self, value, /) | Return self&gt;=value. | | __getattribute__(self, name, /) | Return getattr(self, name). | | __getitem__(...) | x.__getitem__(y) &lt;==&gt; x[y] | | __gt__(self, value, /) | Return self&gt;value. | | __iadd__(self, value, /) | Implement self+=value. | | __imul__(self, value, /) | Implement self*=value. | | __init__(self, /, *args, **kwargs) | Initialize self. See help(type(self)) for accurate signature. | | __iter__(self, /) | Implement iter(self). | | __le__(self, value, /) | Return self&lt;=value. | | __len__(self, /) | Return len(self). | | __lt__(self, value, /) | Return self&lt;value. | | __mul__(self, value, /) | Return self*value.n | | __ne__(self, value, /) | Return self!=value. | | __new__(*args, **kwargs) from builtins.type | Create and return a new object. See help(type) for accurate signature. | | __repr__(self, /) | Return repr(self). | | __reversed__(...) | L.__reversed__() -- return a reverse iterator over the list | | __rmul__(self, value, /) | Return self*value. | | __setitem__(self, key, value, /) | Set self[key] to value. | | __sizeof__(...) | L.__sizeof__() -- size of L in memory, in bytes | | append(...) | L.append(object) -&gt; None -- append object to end | | clear(...) | L.clear() -&gt; None -- remove all items from L | | copy(...) | L.copy() -&gt; list -- a shallow copy of L | | count(...) | L.count(value) -&gt; integer -- return number of occurrences of value | | extend(...) | L.extend(iterable) -&gt; None -- extend list by appending elements from the iterable | | index(...) | L.index(value, [start, [stop]]) -&gt; integer -- return first index of value. | Raises ValueError if the value is not present. | | insert(...) | L.insert(index, object) -- insert object before index | | pop(...) | L.pop([index]) -&gt; item -- remove and return item at index (default last). | Raises IndexError if list is empty or index is out of range. | | remove(...) | L.remove(value) -&gt; None -- remove first occurrence of value. | Raises ValueError if the value is not present. | | reverse(...) | L.reverse() -- reverse *IN PLACE* | | sort(...) | L.sort(key=None, reverse=False) -&gt; None -- stable sort *IN PLACE* | | ---------------------------------------------------------------------- | Data and other attributes defined here: | | __hash__ = None123456789class Dog: # 类名首字母要大写，驼峰体 d_type = \"金毛\" # 公共属性，又称类变量 def say_hi(self): # 类的方法，必须带一个self参数，代表实例本身 print(\"hello , I am a dog,my type is \",self.d_type) # 想调用类里的属性，都要加上self.d1 = Dog() # 生成一个狗的实例d2 = Dog() # 生成一个狗的实例d1.say_hi() # 调用狗这个类的方法 实例.方法d2.say_hi()print(d1.d_type) # 调用Dog类的公共属性 hello , I am a dog,my type is 金毛 hello , I am a dog,my type is 金毛 金毛以上代码就是定义好了Dog这个类，相当于先生成了一个模板，接下来生成了2个实例d1, d2，相当于2条有血有肉的狗被创造出来了。 d_type是类变量，是Dog类下所有实例共有的属性，它存在Dog类本身的内存里。你可以查看d1.d_type,d2.d_type的内存地址，指向的是同一处。 除了共有属性，还有私有属性，比如每条狗的名字、年龄都不一样。 1234567891011121314class Dog: # 类名首字母要大写，驼峰体 d_type = \"金毛\" # 公共属性，又称类变量 def __init__(self,name,age,master): # 初始化函数，只要一实例化，就会自动执行 print('初始化这个实例....',name) self.name = name # self.name 就是实例自己的变量 self.age = age self.master = master def say_hi(self): # 类的方法，必须带一个self参数，代表实例本身 print(\"hello , I am a dog,my type is \",self.d_type) # 想调用类里的属性，都要加上self.d1 = Dog(\"毛毛\",2,\"Alex\") # 生成一个狗的实例d2 = Dog(\"大黄\",3,\"Jack\") # 生成一个狗的实例d1.say_hi() # 调用狗这个类的方法d2.say_hi()print(d2.name, d2.age, d2.master) # 调用实例的变量 初始化这个实例.... 毛毛 初始化这个实例.... 大黄 hello , I am a dog,my type is 金毛 hello , I am a dog,my type is 金毛 大黄 3 Jack我们并没有调用init(self,….)，但它会自动执行，因为它叫初始化函数，就是在实例化的时候，用来初始化一些数据的，比如初始化你实例的名字、年龄等属性。 self就是代表实例本身，你实例化时Python会自动把这个实例本身通过self参数传进去。 self在实例化时自动将对象/实例本身传给init的第一个参数，你也可以给它起个别的名字，但是正常人都不会这么做，因为你瞎改别人就不认识。 属性引用类的公共属性引用（类名.属性）123456class Dog: # 类名首字母要大写，驼峰体 d_type = \"京巴\" # 公共属性，又称类变量 def say_hi(self): print(\"hello , I am a dog,my type is \",self.d_type) print(Dog.d_type) # 查看Dog的d_type属性print(Dog.say_hi) # 引用Dog的say_hi方法，注意只是引用，不是调用 京巴 &lt;function Dog.say_hi at 0x10f045488&gt;实例属性引用(实例名.属性)123456789101112class Dog: # 类名首字母要大写，驼峰体 d_type = \"京巴\" # 公共属性，又称类变量 def __init__(self,name,age,master): # 初始化函数，只要一实例化，就会自动执行 self.name = name # self.name 就是实例自己的变量 self.age = age self.master = master def say_hi(self): print(\"hello , I am a dog,my type is \",self.d_type) d2 = Dog(\"二蛋\",3,\"Jack\") # 生成一个狗的实例d2.say_hi() # 调用狗这个类的方法print(d2.name, d2.age, d2.master) # 调用实例的属性print(d2.d_type) # 注意通过实例也可以调用类的公共属性 hello , I am a dog,my type is 京巴 二蛋 3 Jack 京巴练习设计一个类Person，生成若干实例，在终端输出如下信息 小明，10岁，男，喜欢打篮球 小红，13岁，女，喜欢跳芭蕾 老李，40岁，男，喜欢吹牛 老张… 回顾编程范式：编程方法论 最初，编程就是无组织无结构，按步骤写指令 后来提取重复代码和指令，组织到一起（定义函数），使程序结构化。但此时的数据与动作是分离的（还记得前面人狗大战中的“人咬狗”吗）。 再后来就产生了把数据和动作内嵌到一个结构中的编程方式，创建了对象系统。 12345class Point: '''Represent a point in 2-D space.'''a = Point()print(Point)print(a) &lt;class &apos;__main__.Point&apos;&gt; &lt;__main__.Point object at 0x10f0536d8&gt;1234567891011121314151617181920# 回顾属性引用class Person: nationality = 'TW' #公共属性 def __init__(self, name, age, sex): self.name = name #实例属性 self.age = age self.sex = sexp1 = Person('蔡某某', 50, 'F')p2 = Person('吴某', 34, 'M')# 修改国籍Person.nationality = 'CN'print(p1.nationality)print(p2.nationality)p1.nationality = 'JP' # 实例自己修改了国籍print(p1.nationality)print(Person.nationality) CN CN JP CN练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# 定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法。from math import sqrtclass Point(object): def __init__(self, x=0, y=0): \"\"\"初始化方法 :param x: 横坐标 :param y: 纵坐标 \"\"\" self.x = x self.y = y def move_to(self, x, y): \"\"\"移动到指定位置 :param x: 新的横坐标 \"param y: 新的纵坐标 \"\"\" self.x = x self.y = y def move_by(self, dx, dy): \"\"\"移动指定的增量 :param dx: 横坐标的增量 :param dy: 纵坐标的增量 \"\"\" self.x += dx self.y += dy def distance_to(self, other): \"\"\"计算与另一个点的距离 :param other: 另一个点 \"\"\" dx = self.x - other.x dy = self.y - other.y return sqrt(dx ** 2 + dy ** 2) #特殊方法__str__()用于把一个类的实例变成 str def __str__(self): return '(%s, %s)' % (str(self.x), str(self.y))def main(): p1 = Point(3, 5) p2 = Point() print(p1) print(p2) p2.move_by(-1, 2) print(p2) print(p1.distance_to(p2))if __name__ == '__main__': main() &lt;__main__.Point object at 0x10f098cf8&gt; &lt;__main__.Point object at 0x10f098080&gt; &lt;__main__.Point object at 0x10f098080&gt; 5.0对象间的交互、组合1234567891011121314151617181920212223242526272829class Dog: # 定义一个狗类 role = 'dog' # 狗的角色属性都是狗 def __init__(self, name, breed, attack_val): self.name = name self.breed = breed # 每一只狗都有自己的品种; self.attack_val = attack_val # 每一只狗都有自己的攻击力; self.life_val = 100 # 每一只狗都有自己的生命值; def bite(self, person): # 狗可以咬人，这里传递进来的person也是一个对象。 person.life_val -= self.attack_val # 狗咬人，那么人的生命值就会根据狗的攻击力而下降 print(\"狗[%s]咬了人[%s]，人生命值减少[%s]，还剩[%s]...\" % / (self.name,person.name,self.attack_val,person.life_val))class Person: # 定义一个人类 role = 'person' # 人的角色属性都是人 def __init__(self, name, sex, attack_val): self.name = name self.attack_val = attack_val self.life_val = 100 self.sex = sex def attack(self,dog): # 人可以攻击狗，这里传递进来的dog也是一个对象。 # 人攻击狗，那么狗的生命值就会根据人的攻击力而下降 dog.life_val -= self.attack_val print(\"人[%s]打了狗[%s]，狗生命值减少[%s]，还剩[%s]...\" % / (self.name,dog.name,self.attack_val,dog.life_val))d = Dog(\"大黄\", \"金毛\", 20)p = Person(\"老王\", \"Male\", 60)d.bite(p) # 对象交互, 把p实例传递给d的方法p.attack(d) 狗[大黄]咬了人[老王]，人生命值减少[20]，还剩[80]... 人[老王]打了狗[大黄]，狗生命值减少[60]，还剩[40]... --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-41-89494cc1680a&gt; in &lt;module&gt;() 26 d.bite(p) # 对象交互, 把p实例传递给d的方法 27 p.attack(d) ---&gt; 28 p.bite(d) AttributeError: &apos;Person&apos; object has no attribute &apos;bite&apos;类与类之间的关系大千世界, 万物之间皆有规则和规律. 我们的类和对象是对大千世界中的所有事物进行归类. 那事物之间存在着相对应的关系. 类与类之间也同样如此. 在面向对象的世界中. 类与类中存在以下关系: 依赖关系，狗和主人的关系 关联关系，你和你的工作搭档的关系就是关联关系 聚合关系，电脑的各部件组成完整的电脑，电脑里有CPU, 硬盘, 内存等。 每个组件有自己的生命周期， 电脑挂了. CPU还是好的. 还是完整的个体 组合关系，比聚合还要紧密.比如人的大脑, 心脏, 各个器官. 这些器官组合成一个人. 这时. 人如果挂了. 其他的东西也跟着挂了 继承关系， 类的三大特性之一，子承父业 依赖关系狗和主人的关系可以理解为是一种依赖关系，如果没有主人，它就是流浪狗了，可能会死。 123456789101112class Dog: def __init__(self,name,age,breed): self.name = name self.age = age self.breed = breed class Person: def __init__(self,name,age,sex): self.name = name self.age = age self.sex = sex 12345678910111213141516171819202122class Dog: def __init__(self,name,age,breed,master): self.name = name self.age = age self.breed = breed self.master = master # master传进来的应该是个对象 self.sayhi() # 调用自己的方法在实例化的时候 def sayhi(self): print(\"Hi，我是 %s, 一只%s狗，我的主人是%s\" %/ (self.name,self.breed,self.master.name))class Person: def __init__(self,name,age,sex): self.name = name self.age = age self.sex = sex def walk_dog(self,dog_obj): \"\"\"遛狗\"\"\" print(\"主人[%s]带狗[%s]去遛遛。。。\" % / (self.name,dog_obj.name ))p = Person(\"赵四\", 46, \"Male\")d = Dog(\"小黑\", 5, \"腊肠\", p)p.walk_dog(d) Hi，我是 小黑, 一只腊肠狗，我的主人是赵四 主人[赵四]带狗[小黑]去溜溜。。。关联关系你和你工作搭档的关系 1234567891011121314class Person: def __init__(self,name,age,sex): self.name = name self.age = age self.sex = sex def do_stuff(self): passp1 = Person(\"张三\", 25, \"男\")p2 = Person(\"李四\", 23, \"女\")#建立关联关系#解除关联关系 12345678910111213141516class Person: def __init__(self,name,age,sex): self.name = name self.age = age self.sex = sex self.partner = None # 搭档，是个对象 def do_stuff(self): \"\"\"和搭档一起完成某项工作\"\"\" print(\"%s和%s一起完成项目开发。\" %/ (self.name,self.partner.name))p1 = Person(\"张三\", 25, \"男\")p2 = Person(\"李四\", 23, \"女\")p1.partner = p2 # 两个对象要互相绑定彼此p2.partner = p1p1.do_stuff()p2.do_stuff() 张三和李四一起完成项目开发。 --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-1-e568e80b056e&gt; in &lt;module&gt;() 13 #p2.partner = p1 14 p1.do_stuff() ---&gt; 15 p2.do_stuff() &lt;ipython-input-1-e568e80b056e&gt; in do_stuff(self) 7 def do_stuff(self): 8 &quot;&quot;&quot;和搭档一起完成某项工作&quot;&quot;&quot; ----&gt; 9 print(&quot;%s和%s一起完成项目开发。&quot; %(self.name,self.partner.name)) 10 p1 = Person(&quot;张三&quot;, 25, &quot;男&quot;) 11 p2 = Person(&quot;李四&quot;, 23, &quot;女&quot;) AttributeError: &apos;NoneType&apos; object has no attribute &apos;name&apos;以上虽然实现了2个对象的关联，但细想其实是有问题的，张三和李四需要在自己的实例中分别绑定下彼此才能实现伴侣关系。假如有一方忘记了关联，那这个伙伴关系就只是单方面成立了，李四知道自己的伙伴是张三，张三却不识李四。 为了确保这两人的关系是一致的，怎么办呢？ 可以创建个单独的类，存储2个人的关系状态，2个人在查自己的工作状态时，都到这个单独的实例里来查。 12345678910111213141516171819202122232425262728293031323334353637383940class RelationShip: \"\"\"保存2个人的工作伙伴关系\"\"\" def __init__(self): self.partner = [] def make_partner(self,obj1,obj2): self.partner.append(obj1) self.partner.append(obj2) print(\"[%s] 和 [%s] 成为搭档...\" % (obj1.name,obj2.name)) def break_up(self): if self.partner: print(\"[%s] 和 [%s] 结束搭档关系。\" % (self.partner[0].name,self.partner[1].name)) self.partner.clear() else: print(\"你根本就没搭档...\") def get_my_partner(self,obj): \"\"\"返回我的搭档\"\"\" for i in self.partner: if obj != i: # partner列表里有2个值，一个是我自己，一个是我对象，只要跟传进来的obj不相等，代表找到了我对象 return i.name else: print(\"你没有搭档，自己不知道么....\")class Person: def __init__(self,name,age,sex,relation_obj): self.name = name self.age = age self.sex = sex self.relation = relation_obj # 把RelationShip对象传进来 #self.partner = None # 另一半，是个对象 def do_stuff(self): \"\"\"和搭档一起完成某项工作\"\"\" print(\"%s和%s一起完成项目开发。\" %(self.name,self.relation.get_my_partner(self)))relation_obj = RelationShip()p1 = Person(\"张三\",25,\"男\",relation_obj)p2 = Person(\"李四\",23,\"女\",relation_obj)relation_obj.make_partner(p1,p2) # 把2个人组合在一起p1.do_stuff()p2.do_stuff()p1.relation.break_up() # 结束搭档关系p1.relation.get_my_partner(p1) # 再去查，就没有搭档了p2.relation.get_my_partner(p2) # 再去查，就没有搭档了 [张三] 和 [李四] 成为搭档... 张三和李四一起完成项目开发。 李四和张三一起完成项目开发。 [张三] 和 [李四] 结束搭档关系。 你没有搭档，自己不知道么.... 你没有搭档，自己不知道么....组合关系组合指的是，在一个类中以另外一个类的对象作为数据属性，称为类的组合 由一堆组件构成一个完整的实体，组件本身独立，但又不能自己运行，必须组合在一起运行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Dog: # 定义一个狗类 role = 'dog' # 狗的角色属性都是狗 def __init__(self, name, breed, attack_val): self.name = name self.breed = breed # 每一只狗都有自己的品种; self.attack_val = attack_val # 每一只狗都有自己的攻击力; self.life_val = 100 # 每一只狗都有自己的生命值; def bite(self, person): # 狗可以咬人，这里传递进来的person也是一个对象。 person.life_val -= self.attack_val # 狗咬人，那么人的生命值就会根据狗的攻击力而下降 print(\"狗[%s]咬了人[%s]，人生命值减少[%s]，还剩[%s]...\" % / (self.name,person.name,self.attack_val,person.life_val))class Weapon: def stick(self,obj): \"\"\"打狗棒\"\"\" self.name = \"打狗棒\" self.attack_val = 40 obj.life_val -= self.attack_val self.print_log(obj) def knife(self,obj): \"\"\"屠龙刀\"\"\" self.name = \"屠龙刀\" self.attack_val = 80 obj.life_val -= self.attack_val self.print_log(obj) def gun(self,obj): \"\"\"AK47\"\"\" self.name = \"AK47\" self.attack_val = 100 obj.life_val -= self.attack_val self.print_log(obj) def print_log(self,obj): print(\"[%s]被[%s]攻击了，掉血[%s],还剩血量[%s]...\" %/ (obj.name,self.name,self.attack_val,obj.life_val))class Person: # 定义一个人类 role = 'person' # 人的角色属性都是人 def __init__(self, name, sex, attack_val): self.name = name self.attack_val = attack_val self.life_val = 100 self.sex = sex self.weapon = Weapon() # 在此处实例化一个Weapon对象 def attack(self,dog): # 人可以攻击狗，这里传递进来的dog也是一个对象。 # 人攻击狗，那么狗的生命值就会根据人的攻击力而下降 dog.life_val -= self.attack_val print(\"人[%s]打了狗[%s],狗掉血[%s],还剩血量[%s]...\" % (self.name,dog.name,self.attack_val,dog.life_val))d = Dog(\"大黄\",\"金毛\",30)p = Person(\"老李\",\"Male\",80)d.bite(p) # 对象交互,把p实例传递给d的方法p.attack(d)p.weapon.knife(d) # 通过组合的方式调用weapon实例下的具体武器p.weapon.stick(d) 狗[mjj]咬了人[Alex]，人生命值减少[20]，还剩[80]... 人[Alex]打了狗[mjj],狗掉血[60],还剩血量[40]... [mjj]被[屠龙刀]攻击了，掉血[80],还剩血量[-40]... [mjj]被[打狗棒]攻击了，掉血[40],还剩血量[-80]...用组合的方式建立了类与组合的类之间的关系，它是一种‘有’或者”包含”的关系,比如老师有生日，老师教python课程。 123456789101112131415161718192021222324class BirthDate: def __init__(self, year, month, day): self.year = year self.month = month self.day = dayclass Course: def __init__(self, name, price, period): self.name = name self.price = price self.period = periodclass Teacher: def __init__(self, name, gender, birth, course): self.name = name self.gender = gender self.birth = birth self.course = course def teaching(self): print('teaching.....',self.course.name)p1 = Teacher('Alex', 'Male', BirthDate('1985', '1', '27'), Course('Python', '2800', '1 months') )print(p1.birth.year, p1.birth.month, p1.birth.day)print(p1.course.name, p1.course.price, p1.course.period) 1995 1 27 Python 28000 5 months实践设计一个扑克牌游戏： 两名玩家每人从牌堆中抽出一张牌，牌面最大的玩家获胜 牌面大小比较规则：2 最小，A 最大，值相同则比较花色，’黑桃’&gt;’红桃’&gt;’方块’&gt;’梅花’ 版本 0.1：定义扑克牌及比较规则需要考虑： 扑克牌：花色、牌面 比较规则 1234567891011121314151617181920212223242526272829303132333435363738394041# 扑克牌游戏# 牌面大小比较规则：2 最小，A 最大，值相同则比较花色，'黑桃'&gt;'红桃'&gt;'方块'&gt;'梅花'class Card: suits = ['黑桃','红桃','方块','梅花'] # spades/hearts/diamonds/clubs values = [None, None, '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'] # Jack/Queen/King/Ace # 初始化，为对象传入 v,s 值 def __init__(self, v, s): \"\"\"suit和 value 的值都为整型数\"\"\" self.value = v self.suit = s # 定义__lt__方法，可用小于运算符比较对象，相当于重新定义了&lt; def __lt__(self, c2): if self.value &lt; c2.value: return True if self.value == c2.value: if self.suit &lt; c2.suit: return True else: return False else: return False # 定义__gt__方法，可用大于运算符比较对象，相当于重新定义了&gt; def __gt__(self, c2): pass # 用__repr__方法把一个类的实例变成 str，注意与__str__方法的区别 def __repr__(self): v = self.suits[self.suit] + self.values[self.value] return vc1 = Card(3, 2)c2 = Card(3, 3)print(c1)print(c2)print(c1 &lt; c2) 方块3版本 0.2：定义牌堆需要考虑： 初始化时创建 52 张扑克牌 定义一个方法从牌堆中随机抽一张牌并把牌从牌堆中删除 123456789101112131415from random import shuffleclass Deck: def __init__(self): \"\"\"初始化方法 cards: 列表，用于存储牌堆中的扑克牌 \"\"\" self.cards = [] pass shuffle(self.cards) def rm_card(self): passdeck = Deck()for card in deck.cards: print(card) 版本 0.3：玩家需要考虑： 玩家姓名 记录玩家当前手中的牌 记录玩家赢的局数 123456class Player: def __init__(self, name): \"\"\"初始化方法 :param name: 玩家姓名 \"\"\" pass 版本 0.4：游戏需要考虑： 初始化时获取两名玩家姓名并创建两个玩家对象 初始化时创建一个 Deck 对象 定义一个方法开始游戏，直到玩家选择退出或牌堆中的牌数不足两张 在开始游戏的方法中实现发牌、比较、输出结果 定义一个方法接受两个玩家对象，比较各自赢的局数，返回获胜次数多的玩家 123456789101112131415161718192021class Game: def __init__(self): pass def wins(self, winner): pass def draw(self, p1n, p1c, p2n, p2c): \"\"\"抽牌 :param p1n: 玩家 1 姓名 :param p1c: 玩家 1 手中的牌 :param p2n: 玩家2 姓名 :param p2c: 玩家 2 手中的牌 \"\"\" pass def play_game(self): pass def winner(self, p1, p2): \"\"\"返回比赛结果 :param p1: 玩家 1 :param p2: 玩家 2 \"\"\" pass 版本 1.0：整合12345678910class Card: passclass Deck: passclass Player: passclass Game: passgame = Game()game.play_game() 12 三大特性之-继承继承（inheritance）是面向对象软件技术当中的一个概念。如果一个类别A“继承自”另一个类别B，就把这个A称为“B的子类别”，而把B称为“A的父类别”也可以称“B是A的超类”。 继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。 在子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。 继承与抽象（先抽象再继承）抽象即抽取类似或者说比较像的部分。 抽象分成两个层次： 1.将雷昂纳多和王思聪这俩对象比较像的部分抽取成类； 2.将人，猪，狗这三个类比较像的部分抽取成父类。 抽象最主要的作用是划分类别（可以隔离关注点，降低复杂度） 继承：是基于抽象的结果，通过编程语言去实现它，肯定是先经历抽象这个过程，才能通过继承的方式去表达出抽象的结构。 抽象只是分析和设计的过程中，一个动作或者说一种技巧，通过抽象可以得到类 12345678910111213class Animal: def __init__(self,name,age,sex): self.name = name self.age = age self.sex = sex def eat(self): print(\"[%s] is eating...\" % self.name)class People(Animal): passp = People()p.eat() [q] is eating...123456789101112131415161718192021222324class Animal: type = '哺乳动物' def __init__(self,name,age,sex): self.name = name self.age = age self.sex = sex def eat(self): print(\"[%s] is eating...\" % self.name)class People(Animal): def talk(self): print(\"People [%s] is talking...\" % self.name)class Pig(Animal): def eat(self): #重写 print(\"Pig [%s] is eating...\" % self.name)class Dog(Animal): def chase_rabbit(self): print(\"Dog [%s] is chasing rabbit...\" % self.name)person = People(\"Alex\",25,\"Male\")pig = Pig(\"Mjj\",4,\"公\")dog = Dog(\"毛毛\",3,\"母\")person.talk()pig.eat()dog.chase_rabbit()print(person.type) People [Alex] is talking... Pig [Mjj] is eating... Dog [毛毛] is chasing rabbit... 哺乳动物继承的优点显而易见： 1.增加了类的耦合性。 2.减少了重复代码。 3.使得代码更加规范化，合理化。 继承的分类在上面的例子中： Aminal 叫做父类,基类,超类。 Person Pig Dog: 子类，派生类。 继承：可以分单继承，多继承。 继承父类的方法&amp;重写父类方法123456789101112131415161718192021class Animal: def __init__(self,name,age,sex): self.name = name self.age = age self.sex = sex def eat(self): print(\"[%s] is eating...\"%self.name)class People(Animal): def walk(self): print(\"People [%s] is walking...\" % self.name) class Pig(Animal): def eat(self): # 重写了父类的方法 print(\"Pig [%s] is eating...\" % self.name) person = People(\"Tom\",25,\"Male\")pig = Pig(\"猪坚强\",4,\"公\")person.walk()person.eat() # 继承自父类的eat方法pig.eat() People [Alex] is walking... [Alex] is eating... Pig [Mjj] is eating...同时执行子类&amp;父类方法方法一： 如果想执行父类的init方法，这个方法并且子类中也用，那么就在子类的方法中写上： 父类.func(子类对象,其他参数) 123456789101112131415class Animal: def __init__(self,name,age,sex): self.name = name self.age = age self.sex = sex def eat(self): print(\"[%s] is eating...\"%self.name)class People(Animal): def __init__(self,name,age,sex,race): Animal.__init__(self,name,age,sex) # 先执行父类方法 self.race = race # 再加上子类的属性 print(\"初始化了一个人....\") def walk(self): print(\"People [%s] is walking...\" % self.name)p = People('老李','35','M','汉') 初始化了一个人....方法二： 利用super()，super().func(参数) 1234567class People(Animal): def __init__(self,name,age,sex,race): #Animal.__init__(self,name,age,sex) # 这种方法在Python 2中常用 super(People,self).__init__(name,age,sex) # Python 3中常用 #super().__init__(name,age,sex) # 跟上面这行super语法的效果一样，一般用这种写法的多 self.race = race # 再加上子类的属性 print(\"初始化了一个人....\") 多继承（Multiple Inheritance）1234567891011121314151617class Fairy: \"\"\"神仙类\"\"\" def fly(self): print(\"神仙都会飞...\")class Monkey: def eat_peach(self): print(\"猴子都喜欢吃桃子...\") class MonkeyKing(Fairy,Monkey): def play_goden_stick(self): print(\"孙悟空玩金箍棒...\")m = MonkeyKing()m.eat_peach()m.fly()m.play_goden_stick() 猴子都喜欢吃桃子... 神仙都会飞... 孙悟空玩金箍棒...此时, 孙悟空是一只猴子, 同时也是一个神仙. 那孙悟空继承了这两个类. 孙悟空自然就可以执行这两个类中的方法. 多继承用起来简单. 也很好理解. 假如在继承的多个类里出现了重名的方法怎么办呢？ 比如： 12345678910111213141516class Fairy: \"\"\"神仙类\"\"\" def fly(self): print(\"神仙都会飞...\") def fight(self): print(\"神仙在打架...\")class Monkey: def eat_peach(self): print(\"猴子都喜欢吃桃子...\") def fight(self): print(\"猴子在打架...\")class MonkeyKing(Fairy,Monkey): # 换个位置试一下 def play_goden_stick(self): print(\"孙悟空玩金箍棒...\")m = MonkeyKing()m.fight() 神仙在打架...调用m.fight()会打印哪个呢？ 根据执行结果，我们得知，多继承的顺序是按参数 MonkeyKing(Fairy,Monkey)从左到右。 真的是从左到右么？ 如果继承的父类又继承爷爷类，并且还重名了呢？ 12345678910111213141516171819202122class FairyBase: def fight(self): print(\"神仙祖宗在打架....\")class MonkeyBase: def fight(self): print(\"猿猴在打架....\")class Fairy(FairyBase): \"\"\"神仙类\"\"\" def fly(self): print(\"神仙都会飞...\") def fight(self): print(\"神仙在打架...\")class Monkey(MonkeyBase): def eat_peach(self): print(\"猴子都喜欢吃桃子...\") def fight(self): print(\"猴子在打架...\")class MonkeyKing(Fairy,Monkey): def play_goden_stick(self): print(\"孙悟空玩金箍棒...\")m = MonkeyKing()m.fight() 神仙在打架...此时，若把Fairy类里的fight注释掉，m.fight()会打印哪个？ 是引用Monkey里的fight呢，还是FairyBase里的fight呢？ 这个查找顺序是按什么规则呢？ 在Python 中，有2种类的写法， 不同写法的采用的继承顺序不同 1234class A: # 经典类 pass class B(object): # 新式类 pass 在python 2中，经典类采用的是深度优先查找法， 新式类采用的是广度优先 在python 3中，无论是经典类，还是新式类，都是按广度优先查找 其实是按一个叫C3算法来计算继承顺序的 C3算法不太好理解，不过确实也不太重要。 因为很少有人把继承写的这么复杂。 这种简单的多继承，C3算出来跟深度优先效果一样 三大特性之-封装封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。 要访问该类的代码和数据，必须通过严格的接口控制。 封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。 适当的封装可以让程式码更容易理解与维护，也加强了代码数据的安全性。 123456789class Person: def __init__(self,name,age): self.name = name self.age = age self.life_val = 100p = Person('Kim', 8)p.life_val -= 50print(p.life_val) 封装的优点 良好的封装能够减少耦合。 类内部的结构可以自由修改。 可以对成员变量进行更精确的控制。 隐藏信息，实现细节。 封装原则 将不需要对外提供的内容都隐藏起来； 把属性都隐藏，提供公共方法对其访问。 私有变量和私有方法在python中用双下划线开头的方式将属性隐藏起来（设置成私有的） 私有变量123456789class A: __N = 0 # 类的数据属性就应该是共享的,但是语法上是可以把类的数据属性设置成私有的如__N,会变形为_A__N def __init__(self): self.__X = 10 # 变形为self._A__X def __foo(self): # 变形为_A__foo print('from A') def bar(self): self.__foo() # 只有在类内部才可以通过__foo的形式访问到.# A._A__N是可以访问到的，即这种操作并不是严格意义上的限制外部访问，仅仅只是一种语法意义上的变形 这种自动变形的特点： 1.类中定义的x只能在内部使用，如self.x，引用的就是变形的结果。 2.这种变形其实正是针对外部的变形，在外部是无法通过__x这个名字访问到的。 3.在子类定义的x不会覆盖在父类定义的x，因为子类中变形成了：子类名x,而父类中变形成了：父类名x，即双下滑线开头的属性在继承给子类时，子类是无法覆盖的。 这种变形需要注意的问题是： 1.这种机制也并没有真正意义上限制我们从外部直接访问属性，知道了类名和属性名就可以拼出名字：类名_属性，然后就可以访问了，如a._A__N 2.变形的过程只在类的内部生效,在实例化后再定义的赋值操作，不会变形 私用变量的修改方法举例： 12345678910class Person(object): def __init__(self,name,age): self.name = name self.age = age self.__life_val = 100 def got_attack(self): # 只能通过方法去修改私有变量 self.__life_val -= 20 print(\"got attack ....,life val drops 20, got %s left..\" %self.__life_val)p = Person(\"Jack\",22)p.got_attack() 三大特性之-多态多态概念有时一个对象会有多种表现形式，比如网站页面有个button按钮， 这个button的设计可以不一样(单选框、多选框、圆角的点击按钮、直角的点击按钮等)，尽管长的不一样，但它们都有一个共同调用方式，就是onClick()方法。我们直要在页面上一点击就会触发这个方法。点完后有的按钮会变成选中状态、有的会提交表单、有的甚至会弹窗。这种多个对象共用同一个接口，又表现的形态不一样的现象，就叫做多态( Polymorphism )。 Polymorphism is based on the greek words Poly (many) and morphism (forms). 通过统一函数接口实现多态：12345678910111213class Dog(object): def sound(self): print(\"汪汪汪.....\")class Cat(object): def sound(self): print(\"喵喵喵.....\")def make_sound(animal_type): \"\"\"统一调用接口\"\"\" animal_type.sound() # 不管你传进来是什么动物，我都调用sound()方法dogObj = Dog()catObj = Cat()make_sound(dogObj) make_sound(catObj) 通过抽象类实现多态(最常用)假如你开发一个文本编辑器，支持多种文档类型， 在用户通过你的编辑器打开文件之前，你也不知道准备要打开的是什么类型的文件，可能是pdf,也可能是word. 假如你为每个文件类型都写一个类，每个类都通过show()方法来调用打开对应的文档，为了确保每个类都必须实现show()方法，你可以写一个抽象类。 12345678910111213141516class Document: def __init__(self, name): self.name = name def show(self): # 子类必须重写方法 raise NotImplementedError(\"Subclass must implement abstract method\")class Pdf(Document): def show(self): return 'Show pdf contents!'class Word(Document): def show(self): return 'Show word contents!'documents = [Pdf('Document1'), Pdf('Document2'), Word('Document3')]for document in documents: print(document.name + ': ' + document.show()) 12345678910111213141516171819202122class Car: def __init__(self, name): self.name = name def drive(self): raise NotImplementedError(\"Subclass must implement abstract method\") def stop(self): raise NotImplementedError(\"Subclass must implement abstract method\")class SportsCar(Car): def drive(self): return 'Sportscar driving!' def stop(self): return 'Sportscar braking!'class Truck(Car): def drive(self): return 'Truck driving slowly because heavily loaded.' def stop(self): return 'Truck braking!'cars = [Truck('东风重卡'), Truck('三一重工'), SportsCar('Tesla Roadster')]for car in cars: print(car.name + ': ' + car.drive()) 练习编写一个名为Person的类，其中包含姓名、地址和电话号码的数据属性。 然后，编写一个名为Customer的类，它是Person的子类，Customer类有一个客户编号的数据属性和一个布尔属性（表明客户是否为活跃客户）。 以上部分保存在person.py中，以下程序创建了Customer类的实例并显示它。 123456789101112131415161718192021222324252627282930313233343536import persondef main(): # Local variables name = '' address = '' phone_number = '' cust_number = 0 active_flag = False # Get data attributes. name = input('Enter the name: ') address = input('Enter the address: ') phone_number = input('Enter the phone_number: ') cust_number = input('Enter the customer number: ') active = input('Does the customer active?(Yes/No) ') if active == 'Yes': active_flag = True else: active_flag = False # Create an instance of Customer. customer = person.Customer(name, address, phone_number, \\ cust_number, active_flag) # Display information. print ('Customer information: ') print ('Name:', customer.get_name()) print ('Address:', customer.get_address()) print ('Phone number:', customer.get_phone_number()) print ('Customer Number:', customer.get_cust_number()) print ('Active:', customer.get_active())# Call the main function.main() --------------------------------------------------------------------------- ModuleNotFoundError Traceback (most recent call last) &lt;ipython-input-8-f3eebd31f2c0&gt; in &lt;module&gt;() ----&gt; 1 import person 2 3 def main(): 4 # Local variables 5 name = &apos;&apos; ModuleNotFoundError: No module named &apos;person&apos;练习编写一个名为Employee类，其中包含员工姓名、员工编号信息。 然后，编写一个名为ProductionWorker的类，它是Employee的子类，包含以下信息： 倒班代码（整数） 小时工资 工作日分为两个班次：白班和夜班。班次属性保存代表员工工作班次的整数，白班的班次为1，夜班的班次为2 以上部分保存在emp.py中，以下程序创建了一个ProductionWorker类的实例，提示用户输入相关信息并存储在对象中，然后使用对象的访问器方法提取信息并显示在屏幕上。 1234567891011121314151617181920212223242526272829import empdef main(): # Local variables worker_name= '' worker_id = '' worker_shift = 0 worker_pay = 0.0 # Get data attributes worker_name = input('Enter the name: ') worker_id = input('Enter the ID number: ') worker_shift = int(input('Enter the shift number: ')) worker_pay = float(input('Enter the hourly pay rate: ')) # Create an instance of ProductionWorker worker = emp.ProductionWorker(worker_name, worker_id, \\ worker_shift, worker_pay) # Display information print ('Production worker information:') print ('Name:', worker.get_name()) print ('ID number:', worker.get_id_number()) print ('Shift:', worker.get_shift_number()) print ('Hourly Pay Rate: $', \\ format(worker.get_pay_rate(), ',.2f'), sep='')# Call the main function.main() 12","link":"/2020/05/26/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%BC%BA%E5%8C%96-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"}],"tags":[{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"coding","slug":"coding","link":"/tags/coding/"}],"categories":[]}